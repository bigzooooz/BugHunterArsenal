<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BugHunter Arsenal Control Center</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        :root {
            --bg-primary: #0a0a0a;
            --bg-secondary: #111111;
            --bg-tertiary: #1a1a1a;
            --bg-card: #151515;
            --border-color: #2a2a2a;
            --border-accent: #3a3a3a;
            --text-primary: #e0e0e0;
            --text-secondary: #9a9a9a;
            --text-muted: #666666;
            --accent-primary: #00d9ff;
            --accent-secondary: #00ff88;
            --danger: #ff4444;
            --warning: #ffaa00;
            --success: #00ff88;
            --info: #00d9ff;
            --critical: #ff1744;
            --high: #ff6b00;
            --medium: #ffaa00;
            --low: #00d9ff;
            --info-severity: #00ff88;
        }
        
        body {
            font-family: 'Segoe UI', 'Roboto', -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            font-size: 14px;
            line-height: 1.6;
            overflow-x: hidden;
        }
        
        .topbar {
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            padding: 12px 24px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            position: sticky;
            top: 0;
            z-index: 1000;
            backdrop-filter: blur(10px);
        }
        
        .logo {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .logo-text {
            font-size: 14px;
            color: var(--text-secondary);
            font-weight: 500;
            letter-spacing: 0.5px;
        }
        
        .logo img {
            height: 60px;
            width: auto;
            max-width: 200px;
            object-fit: contain;
            object-position: center;
            display: block;
            margin: -8px 0;
            padding: 4px 0;
        }
        
        .topbar-actions {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .btn {
            padding: 8px 16px;
            border-radius: 6px;
            border: 1px solid var(--border-color);
            background: var(--bg-tertiary);
            color: var(--text-primary);
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            transition: all 0.2s;
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }
        
        .btn:hover {
            background: var(--bg-card);
            border-color: var(--border-accent);
        }
        
        .btn-primary {
            background: var(--accent-primary);
            border-color: var(--accent-primary);
            color: var(--bg-primary);
        }
        
        .btn-primary:hover {
            background: #00c4e6;
        }
        
        .btn-danger {
            background: var(--danger);
            border-color: var(--danger);
            color: white;
        }
        
        .btn-danger:hover {
            background: #ff2222;
        }
        
        .btn-warning {
            background: #ffc107;
            border-color: #ffc107;
            color: #000;
        }
        
        .btn-warning:hover {
            background: #ffb300;
        }
        
        .btn-success {
            background: var(--success);
            border-color: var(--success);
            color: var(--bg-primary);
        }
        
        .container {
            display: grid;
            grid-template-columns: 280px 1fr;
            min-height: calc(100vh - 53px);
        }
        
        .sidebar {
            background: var(--bg-secondary);
            border-right: 1px solid var(--border-color);
            padding: 24px;
            overflow-y: auto;
        }
        
        .sidebar-section {
            margin-bottom: 32px;
        }
        
        .sidebar-title {
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--text-muted);
            margin-bottom: 12px;
        }
        
        .nav-item {
            padding: 10px 12px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            margin-bottom: 4px;
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 13px;
            color: var(--text-secondary);
        }
        
        .nav-item:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }
        
        .nav-item.active {
            background: var(--bg-tertiary);
            color: var(--accent-primary);
            border-left: 3px solid var(--accent-primary);
        }
        
        .nav-item-highlight {
            background: var(--accent-primary) !important;
            color: var(--bg-primary) !important;
            font-weight: 600;
            border-left: 3px solid var(--accent-primary);
        }
        
        .nav-item-highlight:hover {
            background: #00c4e6 !important;
            color: var(--bg-primary) !important;
        }
        
        .nav-item-icon {
            font-size: 16px;
            width: 20px;
            text-align: center;
        }
        
        .btn-filter-compact {
            padding: 6px 10px;
            border-radius: 4px;
            border: 1px solid var(--border-color);
            background: var(--bg-tertiary);
            color: var(--text-primary);
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
            flex: 1;
            min-width: 40px;
        }
        
        .btn-filter-compact:hover {
            background: var(--bg-card);
            border-color: var(--border-accent);
            transform: scale(1.05);
        }
        
        .main-content {
            padding: 24px;
            overflow-y: auto;
        }
        
        .page-header {
            margin-bottom: 24px;
        }
        
        .page-title {
            font-size: 28px;
            font-weight: 700;
            color: var(--text-primary);
            margin-bottom: 8px;
        }
        
        .page-subtitle {
            font-size: 14px;
            color: var(--text-secondary);
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 16px;
            margin-bottom: 24px;
        }
        
        .system-stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 16px;
            margin-bottom: 24px;
        }
        
        .system-stat-card {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 20px;
            position: relative;
            overflow: hidden;
        }
        
        .system-stat-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: var(--accent-secondary);
        }
        
        .system-stat-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }
        
        .system-stat-label {
            font-size: 12px;
            color: var(--text-secondary);
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .system-stat-value {
            font-size: 24px;
            font-weight: 700;
            color: var(--accent-primary);
            line-height: 1.2;
        }
        
        .system-stat-detail {
            font-size: 11px;
            color: var(--text-muted);
            margin-top: 4px;
        }
        
        .progress-bar {
            width: 100%;
            height: 6px;
            background: var(--bg-tertiary);
            border-radius: 3px;
            overflow: hidden;
            margin-top: 8px;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--accent-primary), var(--accent-secondary));
            transition: width 0.3s ease;
        }
        
        .progress-fill.warning {
            background: linear-gradient(90deg, var(--warning), #ff8800);
        }
        
        .progress-fill.danger {
            background: linear-gradient(90deg, var(--danger), #ff0000);
        }
        
        .stat-card {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 20px;
            position: relative;
            overflow: hidden;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .stat-card:hover {
            border-color: var(--accent-primary);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 217, 255, 0.15);
        }
        
        .stat-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: var(--accent-primary);
        }
        
        .stat-value {
            font-size: 32px;
            font-weight: 700;
            color: var(--accent-primary);
            margin-bottom: 4px;
        }
        
        .stat-label {
            font-size: 12px;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .card {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 16px;
        }
        
        .card-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 16px;
            padding-bottom: 12px;
            border-bottom: 1px solid var(--border-color);
        }
        
        .card-title {
            font-size: 16px;
            font-weight: 600;
            color: var(--text-primary);
        }
        
        .card-actions {
            display: flex;
            gap: 8px;
        }
        
        .form-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 16px;
            margin-bottom: 16px;
        }
        
        .form-group {
            margin-bottom: 16px;
        }
        
        .form-label {
            display: block;
            font-size: 12px;
            font-weight: 500;
            color: var(--text-secondary);
            margin-bottom: 6px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .form-input,
        .form-select,
        .form-textarea {
            width: 100%;
            padding: 10px 12px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            color: var(--text-primary);
            font-size: 13px;
            font-family: inherit;
            transition: all 0.2s;
        }
        
        .form-input:focus,
        .form-select:focus,
        .form-textarea:focus {
            outline: none;
            border-color: var(--accent-primary);
            box-shadow: 0 0 0 3px rgba(0, 217, 255, 0.1);
        }
        
        .form-textarea {
            resize: vertical;
            min-height: 80px;
            font-family: 'Courier New', monospace;
        }
        
        .form-checkbox {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
        }
        
        .form-checkbox input {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }
        
        .console {
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 16px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            color: var(--text-secondary);
            max-height: 400px;
            overflow-y: auto;
            white-space: pre-wrap;
            word-break: break-all;
        }
        
        .console::-webkit-scrollbar {
            width: 8px;
        }
        
        .console::-webkit-scrollbar-track {
            background: var(--bg-secondary);
        }
        
        .console::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 4px;
        }
        
        .findings-table {
            width: 100%;
            border-collapse: collapse;
        }
        
        .findings-table th,
        .findings-table td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid var(--border-color);
        }
        
        .findings-table th {
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: var(--text-muted);
            background: var(--bg-secondary);
            position: sticky;
            top: 0;
        }
        
        .findings-table td {
            font-size: 13px;
            color: var(--text-primary);
        }
        
        .findings-table tr:hover {
            background: var(--bg-secondary);
        }
        
        .config-tabs {
            display: flex;
            gap: 8px;
            border-bottom: 1px solid var(--border-color);
            margin-bottom: 0;
        }
        
        .config-tab {
            padding: 12px 20px;
            background: none;
            border: none;
            border-bottom: 2px solid transparent;
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s;
        }
        
        .config-tab:hover {
            color: var(--text-primary);
            background: var(--bg-tertiary);
        }
        
        .config-tab.active {
            color: var(--accent-primary);
            border-bottom-color: var(--accent-primary);
            background: var(--bg-tertiary);
        }
        
        .config-tab-content {
            display: none;
        }
        
        .config-tab-content.active {
            display: block;
        }
        
        .config-table {
            width: 100%;
            border-collapse: collapse;
        }
        
        .config-table th,
        .config-table td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid var(--border-color);
        }
        
        .config-table th {
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: var(--text-muted);
            background: var(--bg-secondary);
        }
        
        .config-table td {
            font-size: 13px;
            color: var(--text-primary);
        }
        
        .config-table tr.deleted {
            opacity: 0.5;
        }
        
        .config-table tr:hover {
            background: var(--bg-secondary);
        }
        
        .badge {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .badge-user {
            background: rgba(0, 217, 255, 0.2);
            color: var(--accent-primary);
            border: 1px solid var(--accent-primary);
        }
        
        .badge-system {
            background: rgba(155, 155, 155, 0.2);
            color: var(--text-secondary);
            border: 1px solid var(--border-color);
        }
        
        .badge-default {
            background: rgba(0, 255, 136, 0.2);
            color: var(--success);
            border: 1px solid var(--success);
        }
        
        .badge-deleted {
            background: rgba(255, 68, 68, 0.2);
            color: var(--danger);
            border: 1px solid var(--danger);
        }
        
        .monospace {
            font-family: 'Courier New', monospace;
            font-size: 12px;
        }
        
        .config-actions {
            display: flex;
            gap: 4px;
        }
        
        .config-actions .btn {
            padding: 4px 8px;
            font-size: 12px;
        }
        
        .severity-badge {
            display: inline-block;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .severity-critical {
            background: rgba(255, 23, 68, 0.2);
            color: var(--critical);
            border: 1px solid var(--critical);
        }
        
        .severity-high {
            background: rgba(255, 107, 0, 0.2);
            color: var(--high);
            border: 1px solid var(--high);
        }
        
        .severity-medium {
            background: rgba(255, 170, 0, 0.2);
            color: var(--medium);
            border: 1px solid var(--medium);
        }
        
        .severity-low {
            background: rgba(0, 217, 255, 0.2);
            color: var(--low);
            border: 1px solid var(--low);
        }
        
        .severity-info {
            background: rgba(0, 255, 136, 0.2);
            color: var(--info-severity);
            border: 1px solid var(--info-severity);
        }
        
        .false-positive-badge {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 500;
            background: rgba(102, 102, 102, 0.2);
            color: var(--text-muted);
            border: 1px solid var(--text-muted);
        }
        
        .badge-fp {
            background: rgba(255, 170, 0, 0.2);
            color: var(--warning);
            border: 1px solid var(--warning);
        }
        
        .verified-badge {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 600;
            background: rgba(0, 255, 136, 0.3);
            color: var(--success);
            border: 2px solid var(--success);
            box-shadow: 0 0 8px rgba(0, 255, 136, 0.4);
        }
        
        .finding-verified {
            background: rgba(0, 255, 136, 0.05) !important;
            border-left: 4px solid var(--success) !important;
        }
        
        .finding-verified:hover {
            background: rgba(0, 255, 136, 0.1) !important;
        }
        
        .action-btn {
            padding: 4px 8px;
            border-radius: 4px;
            border: 1px solid var(--border-color);
            background: var(--bg-tertiary);
            color: var(--text-primary);
            cursor: pointer;
            font-size: 11px;
            transition: all 0.2s;
        }
        
        .action-btn:hover {
            background: var(--bg-secondary);
        }
        
        .action-btn-small {
            padding: 2px 6px;
            font-size: 10px;
        }
        
        .btn-stop {
            padding: 4px 10px;
            font-size: 11px;
            border-radius: 4px;
        }
        
        .running-scan-item {
            padding: 12px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            justify-content: space-between;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .running-scan-item:hover {
            background: var(--bg-secondary);
        }
        
        .running-scan-item:last-child {
            border-bottom: none;
        }
        
        .running-scan-info {
            flex: 1;
        }
        
        .running-scan-title {
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 4px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .running-scan-details {
            font-size: 11px;
            color: var(--text-secondary);
        }
        
        .running-scan-params {
            font-size: 10px;
            color: var(--text-muted);
            margin-top: 2px;
            line-height: 1.3;
        }
        
        .running-scan-output {
            font-size: 10px;
            color: var(--accent-primary);
            margin-top: 4px;
            font-family: 'Courier New', monospace;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 100%;
        }
        
        .spinner {
            display: inline-block;
            width: 14px;
            height: 14px;
            border: 2px solid var(--border-color);
            border-top-color: var(--accent-primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }
        
        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }
        
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            z-index: 2000;
            align-items: center;
            justify-content: center;
        }
        
        .modal.active {
            display: flex;
        }
        
        .modal-content {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 24px;
            max-width: 600px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
        }
        
        .modal-content-large {
            max-width: 90%;
            width: 90%;
        }
        
        .modal-console {
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 16px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            color: var(--text-secondary);
            max-height: 60vh;
            overflow-y: auto;
            white-space: pre-wrap;
            word-break: break-all;
            margin-top: 16px;
        }
        
        .modal-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 20px;
            padding-bottom: 16px;
            border-bottom: 1px solid var(--border-color);
        }
        
        .modal-title {
            font-size: 20px;
            font-weight: 600;
            color: var(--text-primary);
        }
        
        .modal-close {
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 24px;
            cursor: pointer;
            padding: 0;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
        }
        
        .modal-close:hover {
            background: var(--bg-secondary);
            color: var(--text-primary);
        }
        
        .select-all {
            margin-bottom: 12px;
            padding: 8px 12px;
            background: var(--bg-secondary);
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        .checkbox-cell {
            width: 40px;
            text-align: center;
        }
        
        .key-value {
            font-family: 'Courier New', monospace;
            font-size: 11px;
            color: var(--text-secondary);
            max-width: 300px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        .key-value:hover {
            color: var(--text-primary);
        }
        
        .filters {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
            margin-bottom: 16px;
            padding: 16px;
            background: var(--bg-secondary);
            border-radius: 6px;
        }
        
        .filter-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .filter-label {
            font-size: 12px;
            color: var(--text-secondary);
        }
        
        .page-content {
            display: none;
        }
        
        .page-content.active {
            display: block;
        }
        
        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: var(--text-muted);
        }
        
        .empty-state-icon {
            font-size: 48px;
            margin-bottom: 16px;
            opacity: 0.5;
        }
        
        .scan-item {
            padding: 16px;
            border-bottom: 1px solid var(--border-color);
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .scan-item:hover {
            background: var(--bg-secondary);
        }
        
        .scan-item:last-child {
            border-bottom: none;
        }
        
        .scan-item-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 8px;
        }
        
        .scan-item-title {
            font-weight: 600;
            color: var(--text-primary);
        }
        
        .status-badge {
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
        }
        
        .status-running {
            background: rgba(0, 217, 255, 0.2);
            color: var(--accent-primary);
        }
        
        .status-paused {
            background: rgba(255, 193, 7, 0.2);
            color: #ffc107;
        }
        
        .status-completed {
            background: rgba(0, 255, 136, 0.2);
            color: var(--success);
        }
        
        .status-failed {
            background: rgba(255, 68, 68, 0.2);
            color: var(--danger);
        }
        
        .domain-card {
            border-bottom: 1px solid var(--border-color);
            padding: 16px;
        }
        
        .domain-card:last-child {
            border-bottom: none;
        }
        
        .domain-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 12px;
            cursor: pointer;
        }
        
        .domain-name {
            font-weight: 600;
            color: var(--accent-primary);
            font-size: 16px;
        }
        
        .domain-stats {
            display: flex;
            gap: 16px;
            font-size: 12px;
            color: var(--text-secondary);
        }
        
        .toggle-icon {
            color: var(--text-secondary);
            transition: transform 0.2s;
        }
        
        .toggle-icon.open {
            transform: rotate(90deg);
        }
        
        .url-list {
            display: none;
            padding: 0;
            border-top: 1px solid var(--border-color);
        }
        
        .url-list.active {
            display: block;
        }
        
        .url-findings-details {
            margin-top: 12px;
        }
        
        .domain-card {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            margin-bottom: 16px;
            overflow: hidden;
        }
        
        .domain-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 16px;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
        }
        
        .domain-name {
            font-size: 16px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 6px;
        }
        
        .domain-stats {
            font-size: 12px;
            color: var(--text-secondary);
        }
        
        .subdomain-item {
            margin-bottom: 12px;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            overflow: hidden;
            background: var(--bg-secondary);
        }
        
        .subdomain-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .subdomain-header:hover {
            background: var(--bg-tertiary);
        }
        
        .subdomain-urls {
            display: none;
            padding: 12px;
            background: var(--bg-primary);
            border-top: 1px solid var(--border-color);
        }
        
        .subdomain-urls.active {
            display: block;
        }
        
        .pagination {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-top: 20px;
            padding: 16px;
            background: var(--bg-secondary);
            border-radius: 6px;
            border: 1px solid var(--border-color);
        }
        
        .pagination-info {
            display: flex;
            align-items: center;
            gap: 16px;
            font-size: 13px;
            color: var(--text-secondary);
        }
        
        .pagination-controls {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .pagination-btn {
            padding: 6px 12px;
            border-radius: 4px;
            border: 1px solid var(--border-color);
            background: var(--bg-tertiary);
            color: var(--text-primary);
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
        }
        
        .pagination-btn:hover:not(:disabled) {
            background: var(--bg-card);
            border-color: var(--border-accent);
        }
        
        .pagination-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .pagination-btn.active {
            background: var(--accent-primary);
            border-color: var(--accent-primary);
            color: var(--bg-primary);
        }
        
        .rows-per-page {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
            color: var(--text-secondary);
        }
        
        .rows-per-page select {
            padding: 4px 8px;
            border-radius: 4px;
            border: 1px solid var(--border-color);
            background: var(--bg-tertiary);
            color: var(--text-primary);
            font-size: 12px;
        }
        
        .url-item {
            padding: 12px;
            background: var(--bg-secondary);
            border-radius: 6px;
            margin-bottom: 8px;
        }
        
        .url-link {
            color: var(--accent-secondary);
            text-decoration: none;
            font-size: 12px;
            word-break: break-all;
            word-break: break-all;
        }
        
        .url-link:hover {
            text-decoration: underline;
        }
        
        .provider-section {
            margin-top: 12px;
            padding: 12px;
            background: var(--bg-tertiary);
            border-radius: 6px;
            border-left: 3px solid var(--accent-primary);
        }
        
        .provider-title {
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 8px;
            font-size: 13px;
        }
        
        .key-item {
            padding: 10px;
            background: var(--bg-primary);
            border-radius: 4px;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
        }
        
        .key-item-content {
            flex: 1;
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .key-text {
            font-family: 'Courier New', monospace;
            font-size: 11px;
            color: var(--text-secondary);
            word-break: break-all;
            flex: 1;
        }
        
        .key-actions {
            display: flex;
            gap: 6px;
        }
        
        /* Wizard Styles */
        .wizard-step {
            max-width: 900px;
            margin: 0 auto;
        }
        
        .scan-type-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 16px;
            margin-bottom: 24px;
        }
        
        .scan-type-card {
            background: var(--bg-card);
            border: 2px solid var(--border-color);
            border-radius: 8px;
            padding: 20px;
            cursor: pointer;
            transition: all 0.2s;
            text-align: center;
        }
        
        .scan-type-card:hover {
            border-color: var(--accent-primary);
            background: var(--bg-tertiary);
            transform: translateY(-2px);
        }
        
        .scan-type-card.selected {
            border-color: var(--accent-primary);
            background: var(--bg-tertiary);
            box-shadow: 0 0 0 3px rgba(0, 217, 255, 0.1);
        }
        
        .scan-type-icon {
            font-size: 32px;
            margin-bottom: 12px;
        }
        
        .scan-type-title {
            font-size: 16px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 8px;
        }
        
        .scan-type-desc {
            font-size: 12px;
            color: var(--text-secondary);
            line-height: 1.4;
        }
        
        .sidebar-drawer-toggle {
            display: none;
            align-items: center;
            justify-content: center;
            width: 40px;
            height: 40px;
            padding: 0;
            border-radius: 6px;
            border: 1px solid var(--border-color);
            background: var(--bg-tertiary);
            color: var(--text-primary);
            cursor: pointer;
            font-size: 20px;
            transition: all 0.2s;
        }
        
        .sidebar-drawer-toggle:hover {
            background: var(--bg-card);
            border-color: var(--border-accent);
        }
        
        .sidebar-overlay {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1100;
            opacity: 0;
            transition: opacity 0.25s ease;
        }
        
        body.drawer-open .sidebar-overlay {
            opacity: 1;
        }
        
        @media (max-width: 1024px) {
            body.drawer-open {
                overflow: hidden;
            }
            
            .sidebar-overlay {
                top: 53px;
            }
            
            .container {
                grid-template-columns: 1fr;
            }
            
            .sidebar-drawer-toggle {
                display: flex;
            }
            
            .sidebar {
                position: fixed;
                top: 53px;
                left: 0;
                bottom: 0;
                width: 280px;
                max-width: 85vw;
                z-index: 1200;
                transform: translateX(-100%);
                transition: transform 0.25s ease;
                box-shadow: 4px 0 24px rgba(0, 0, 0, 0.4);
            }
            
            body.drawer-open .sidebar {
                transform: translateX(0);
            }
            
            body.drawer-open .sidebar-overlay {
                display: block;
            }
        }
    </style>
</head>
<body>
    <div class="sidebar-overlay" id="sidebarOverlay" onclick="closeDrawer()" aria-hidden="true"></div>
    
    <div class="topbar">
        <button type="button" class="sidebar-drawer-toggle" id="sidebarDrawerToggle" onclick="toggleDrawer()" title="Open menu" aria-label="Open menu">‚ò∞</button>
        <div class="logo">
            <img src="logo.png" alt="BugHunter Arsenal">
            <span class="logo-text">BugHunter Arsenal</span>
        </div>
        <div class="topbar-actions">
            <button class="btn" onclick="showPage('about')">‚ÑπÔ∏è About</button>
        </div>
    </div>
    
    <div class="container">
        <div class="sidebar" id="sidebar">
            <div class="sidebar-section">
                <div class="sidebar-title">Navigation</div>
                <div class="nav-item active" onclick="showPage('dashboard')">
                    <span class="nav-item-icon">üìä</span>
                    <span>Dashboard</span>
                </div>
                <div class="nav-item" onclick="showPage('targets')">
                    <span class="nav-item-icon">üéØ</span>
                    <span>Targets</span>
                </div>
                <div class="nav-item" onclick="showPage('findings')">
                    <span class="nav-item-icon">üîç</span>
                    <span>All Findings</span>
                </div>
                <div class="nav-item" onclick="showPage('scans')">
                    <span class="nav-item-icon">‚ö°</span>
                    <span>Scans</span>
                </div>
                <div class="nav-item" onclick="showPage('logs')">
                    <span class="nav-item-icon">üìã</span>
                    <span>Logs</span>
                </div>
                <div class="nav-item" onclick="showPage('settings')">
                    <span class="nav-item-icon">‚öôÔ∏è</span>
                    <span>Settings</span>
                </div>
                <div class="nav-item nav-item-highlight" onclick="showPage('new-scan')">
                    <span class="nav-item-icon">‚ûï</span>
                    <span>New Scan</span>
                </div>
            </div>
            
            <div class="sidebar-section" style="margin-bottom: 16px;">
                <div class="sidebar-title">Quick Filters</div>
                <div style="display: flex; flex-wrap: wrap; gap: 4px;">
                    <button class="btn-filter-compact" onclick="filterBySeverity('critical')" title="Critical">üî¥</button>
                    <button class="btn-filter-compact" onclick="filterBySeverity('high')" title="High">üü†</button>
                    <button class="btn-filter-compact" onclick="filterBySeverity('medium')" title="Medium">üü°</button>
                    <button class="btn-filter-compact" onclick="showFalsePositives()" title="False Positives">‚ö†Ô∏è</button>
                </div>
            </div>
        </div>
        
        <div class="main-content">
            <!-- Dashboard Page -->
            <div id="page-dashboard" class="page-content active">
                <div class="stats-grid" id="statsGrid"></div>
                
                <div class="system-stats-grid" id="systemStatsGrid"></div>
                
                <div class="card" id="runningScansCard" style="display: none;">
                    <div class="card-header">
                        <div class="card-title">Currently Running Scans</div>
                        <button class="btn" onclick="showPage('scans')">View All Scans</button>
                    </div>
                    <div id="runningScansDashboard"></div>
                </div>
                
                <div class="card" id="recentFindingsCard" style="display: none;">
                    <div class="card-header">
                        <div class="card-title">Recent Findings</div>
                        <button class="btn" onclick="showPage('findings')">View All</button>
                    </div>
                    <div id="recentFindings"></div>
                    <div id="recentFindingsPagination"></div>
                </div>
                
            </div>
            
            <!-- Findings Page -->
            <div id="page-findings" class="page-content">                
                <div class="filters" id="findingsFilters">
                    <div class="filter-group">
                        <span class="filter-label">Severity:</span>
                        <select class="form-select" id="filterSeverity" onchange="loadFindings()" style="width: 120px;">
                            <option value="">All</option>
                            <option value="critical">Critical</option>
                            <option value="high">High</option>
                            <option value="medium">Medium</option>
                            <option value="low">Low</option>
                            <option value="info">Info</option>
                        </select>
                    </div>
                    <div class="filter-group">
                        <span class="filter-label">False Positive:</span>
                        <select class="form-select" id="filterFalsePositive" onchange="loadFindings()" style="width: 120px;">
                            <option value="">All</option>
                            <option value="false">No</option>
                            <option value="true">Yes</option>
                        </select>
                    </div>
                    <div class="filter-group">
                        <span class="filter-label">Verified:</span>
                        <select class="form-select" id="filterVerified" onchange="loadFindings()" style="width: 120px;">
                            <option value="">All</option>
                            <option value="false">Unverified</option>
                            <option value="true">Verified</option>
                        </select>
                    </div>
                    <div class="filter-group">
                        <span class="filter-label">Provider:</span>
                        <input type="text" class="form-input" id="filterProvider" placeholder="Filter by provider" style="width: 200px;" oninput="loadFindings()">
                    </div>
                    <div class="filter-group">
                        <span class="filter-label">Domain:</span>
                        <input type="text" class="form-input" id="filterDomain" placeholder="Filter by domain" style="width: 200px;" oninput="loadFindings()">
                    </div>
                </div>
                
                <div class="card">
                    <div class="card-header">
                        <div class="card-title">Findings</div>
                        <div class="card-actions">
                            <div class="select-all">
                                <label class="form-checkbox">
                                    <input type="checkbox" id="selectAllFindings" onchange="toggleSelectAll()">
                                    <span>Select All</span>
                                </label>
                                <div>
                                    <button class="btn btn-success action-btn-small" onclick="bulkUpdate('severity')">Set Severity</button>
                                    <button class="btn action-btn-small" onclick="bulkUpdate('false_positive')">Flag FP</button>
                                    <button class="btn btn-danger action-btn-small" onclick="bulkDelete()">Delete</button>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div id="findingsTableContainer"></div>
                    <div id="findingsPagination"></div>
                </div>
            </div>
            
            <!-- Scans Page -->
            <div id="page-scans" class="page-content">
                <div class="card">
                    <div class="card-header">
                        <div class="card-title">Running Scans</div>
                    </div>
                    <div id="runningScans"></div>
                </div>
                
                <div class="card">
                    <div class="card-header">
                        <div class="card-title">Scan History</div>
                        <div class="card-actions">
                            <div class="select-all" style="margin: 0;">
                                <label class="form-checkbox">
                                    <input type="checkbox" id="selectAllScans" onchange="toggleSelectAllScans()">
                                    <span>Select All</span>
                                </label>
                                <button class="btn btn-danger action-btn-small" onclick="bulkDeleteScans()" id="bulkDeleteScansBtn" style="display: none;">Delete Selected</button>
                            </div>
                        </div>
                    </div>
                    <div id="scanHistory"></div>
                    <div id="scansPagination"></div>
                </div>
                
                <div class="card">
                    <div class="card-header">
                        <div class="card-title">Scan Output</div>
                    </div>
                    <div class="console" id="scanConsole">No scan selected. Click on a scan to view output.</div>
                </div>
            </div>
            
            <!-- Targets Page -->
            <div id="page-targets" class="page-content">
                <div class="page-header">
                    <div class="page-title">Targets</div>
                    <div class="page-subtitle">Manage your targets and navigate to detailed views</div>
                </div>
                
                <div class="filters" id="targetsFilters" style="margin-bottom: 16px;">
                    <div class="filter-group">
                        <span class="filter-label">Filter:</span>
                        <input type="text" class="form-input" id="filterTargetDomain" placeholder="Search targets..." style="width: 300px;" oninput="loadTargets()">
                    </div>
                    <div class="filter-group">
                        <span class="filter-label">Min Findings:</span>
                        <input type="number" class="form-input" id="filterMinFindings" placeholder="0" min="0" style="width: 100px;" oninput="loadTargets()">
                    </div>
                    <div class="card-actions">
                        <button class="btn btn-primary" onclick="showCreateTargetModal()">‚ûï Add Target</button>
                        <button class="btn" onclick="loadTargets()">üîÑ Refresh</button>
                    </div>
                </div>
                
                <div class="card" style="margin-bottom: 16px;">
                    <div class="card-header">
                        <div class="card-title">Export Data</div>
                    </div>
                    <div style="padding: 16px;">
                        <div style="display: flex; gap: 16px; align-items: center; flex-wrap: wrap;">
                            <div class="filter-group">
                                <span class="filter-label">Export Type:</span>
                                <select class="form-input" id="exportType" style="width: 150px;">
                                    <option value="urls">URLs</option>
                                    <option value="subdomains">Subdomains</option>
                                    <option value="findings">Findings</option>
                                </select>
                            </div>
                            <div class="filter-group">
                                <span class="filter-label">Scope:</span>
                                <select class="form-input" id="exportScope" style="width: 150px;">
                                    <option value="all">All Targets</option>
                                    <option value="target">Selected Target</option>
                                    <option value="subdomain">Selected Subdomain</option>
                                </select>
                            </div>
                            <div class="filter-group">
                                <span class="filter-label">Format:</span>
                                <select class="form-input" id="exportFormat" style="width: 120px;">
                                    <option value="json">JSON</option>
                                    <option value="csv">CSV</option>
                                    <option value="txt">TXT</option>
                                </select>
                            </div>
                            <button class="btn btn-primary" onclick="exportTargets()">üì• Export</button>
                        </div>
                        <div id="exportStatus" style="margin-top: 8px; font-size: 12px; color: var(--text-secondary);"></div>
                    </div>
                </div>
                
                <div class="card">
                    <div class="card-header">
                        <div class="card-title">Targets</div>
                    </div>
                    <div id="targetsList"></div>
                    <div id="targetsPagination"></div>
                </div>
            </div>
            
            <!-- Target Detail Page -->
            <div id="page-target-detail" class="page-content">
                <div class="page-header" style="display: flex; align-items: center; justify-content: space-between;">
                    <div>
                        <button class="btn" onclick="showPage('targets')" style="margin-bottom: 8px;">‚Üê Back to Targets</button>
                        <div class="page-title" id="targetDetailTitle">Target Details</div>
                        <div class="page-subtitle" id="targetDetailSubtitle">View and manage all target information</div>
                    </div>
                    <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                        <button class="btn btn-success" onclick="rescanTarget()" title="Re-scan existing URLs for API keys">üîç Re-scan URLs</button>
                        <button class="btn btn-success" onclick="recrawlTarget()" title="Re-crawl URLs from existing subdomains">üï∑Ô∏è Re-crawl URLs</button>
                        <button class="btn btn-success" onclick="rediscoverTarget()" title="Re-discover subdomains and crawl URLs">üåê Re-discover</button>
                        <button class="btn btn-primary" onclick="showRenameTargetModal()">‚úèÔ∏è Rename</button>
                        <button class="btn btn-danger" onclick="deleteCurrentTarget()">üóëÔ∏è Delete</button>
                    </div>
                </div>
                
                <div id="targetDetailContent"></div>
            </div>
            
            <!-- Settings Page -->
            <!-- Logs Page -->
            <div id="page-logs" class="page-content">
                <div class="page-header">
                    <div class="page-title">Server Logs</div>
                    <div class="page-subtitle">View and manage server logs</div>
                </div>
                
                <div class="card">
                    <div class="card-header">
                        <div class="card-title">Log Entries</div>
                        <div style="display: flex; gap: 8px;">
                            <input type="number" id="logsLinesInput" value="1000" min="100" max="10000" step="100" style="width: 120px; padding: 6px 10px; border: 1px solid var(--border-color); border-radius: 4px; background: var(--bg-primary); color: var(--text-primary);">
                            <button class="btn" onclick="loadLogs()">Refresh</button>
                            <button class="btn btn-danger" onclick="clearLogs()">Clear Logs</button>
                        </div>
                    </div>
                    <div id="logsInfo" style="padding: 12px 16px; font-size: 12px; color: var(--text-secondary); border-bottom: 1px solid var(--border-color);">
                        Loading logs...
                    </div>
                    <div id="logsContent" class="console" style="max-height: 70vh; padding: 16px; font-size: 11px; line-height: 1.5;">
                        Loading logs...
                    </div>
                </div>
            </div>
            
            <!-- Settings Page -->
            <div id="page-settings" class="page-content">
                <div class="page-header">
                    <div class="page-title">Settings</div>
                    <div class="page-subtitle">Manage API patterns, excluded extensions, and XSS payloads</div>
                </div>
                
                <!-- Tabs -->
                <div class="card" style="margin-bottom: 16px;">
                    <div class="card-header">
                        <div class="card-title">Configuration Management</div>
                        <div class="card-actions">
                            <button class="btn" onclick="syncConfigsFromYaml()">üîÑ Sync from YAML</button>
                        </div>
                    </div>
                    <div style="padding: 16px;">
                        <div class="config-tabs">
                            <button class="config-tab active" onclick="switchConfigTab('api_patterns')">üîë API Patterns</button>
                            <button class="config-tab" onclick="switchConfigTab('excluded_extensions')">üìÅ Excluded Extensions</button>
                            <button class="config-tab" onclick="switchConfigTab('xss_payloads')">‚ö†Ô∏è XSS Payloads</button>
                        </div>
                    </div>
                </div>
                
                <!-- API Patterns Tab -->
                <div id="config-tab-api_patterns" class="config-tab-content active">
                    <div class="card">
                        <div class="card-header">
                            <div class="card-title">API Patterns</div>
                            <div class="card-actions">
                                <button class="btn btn-primary" onclick="showAddApiPatternModal()">‚ûï Add Pattern</button>
                            </div>
                        </div>
                        <div style="padding: 16px;">
                            <div id="apiPatternsTableContainer"></div>
                        </div>
                    </div>
                </div>
                
                <!-- Excluded Extensions Tab -->
                <div id="config-tab-excluded_extensions" class="config-tab-content">
                    <div class="card">
                        <div class="card-header">
                            <div class="card-title">Excluded Extensions</div>
                            <div class="card-actions">
                                <button class="btn btn-primary" onclick="showAddExtensionModal()">‚ûï Add Extension</button>
                            </div>
                        </div>
                        <div style="padding: 16px;">
                            <div id="excludedExtensionsTableContainer"></div>
                        </div>
                    </div>
                </div>
                
                <!-- XSS Payloads Tab -->
                <div id="config-tab-xss_payloads" class="config-tab-content">
                    <div class="card">
                        <div class="card-header">
                            <div class="card-title">XSS Payloads</div>
                            <div class="card-actions">
                                <button class="btn btn-primary" onclick="showAddXssPayloadModal()">‚ûï Add Payload</button>
                            </div>
                        </div>
                        <div style="padding: 16px;">
                            <div id="xssPayloadsTableContainer"></div>
                        </div>
                    </div>
                </div>
                
                <div id="configStatusMessage" style="margin-top: 12px; padding: 12px; border-radius: 6px; display: none;"></div>
            </div>
            
            <!-- About Page -->
            <div id="page-about" class="page-content">
            
                <div class="card">
                    <div class="card-header">
                        <div class="card-title">About BugHunter Arsenal</div>
                    </div>
                    <div style="text-align: center; margin-bottom: 20px;">
                        <img src="logo-with-text.png" alt="BugHunter Arsenal Logo" style="max-width: 400px; height: auto;">
                        <p id="aboutVersion" style="margin-top: 16px; font-size: 16px; color: var(--text-secondary);">Version <span id="appVersion">1.0.0</span></p>
                    </div>
                    <div style="line-height: 1.8;">
                        <p>BugHunter Arsenal is a comprehensive, unified security scanning platform designed for bug bounty hunters and security researchers. It provides a single interface to run multiple specialized security tools simultaneously, making vulnerability discovery more efficient and organized.</p>
                        
                        <p style="margin-top: 16px;">Unlike standalone security tools, BugHunter Arsenal orchestrates multiple scanners through a unified web dashboard and command-line interface, allowing you to discover vulnerabilities across different attack vectors in parallel.</p>
                        
                        <h3 style="margin-top: 32px; margin-bottom: 16px; color: var(--accent-primary);">Available Tools</h3>
                        <div style="display: grid; gap: 16px; margin-top: 16px;">
                            <div style="padding: 16px; background: var(--bg-tertiary); border-radius: 8px; border-left: 3px solid var(--accent-primary);">
                                <h4 style="color: var(--accent-primary); margin-bottom: 8px;">üîë KeyHunter</h4>
                                <p style="color: var(--text-secondary); margin: 0;">API Key Detection & Validation. Scans domains, subdomains, and URLs for exposed API keys and secrets from 50+ providers. Includes real-time validation for 33+ providers.</p>
                            </div>
                            <div style="padding: 16px; background: var(--bg-tertiary); border-radius: 8px; border-left: 3px solid var(--accent-primary);">
                                <h4 style="color: var(--accent-primary); margin-bottom: 8px;">üéØ XSSHunter</h4>
                                <p style="color: var(--text-secondary); margin: 0;">Reflected Cross-Site Scripting (XSS) Vulnerability Scanner. Detects XSS vulnerabilities in URL parameters using 911+ customizable payloads.</p>
                            </div>
                            <div style="padding: 16px; background: var(--bg-tertiary); border-radius: 8px; border-left: 3px solid var(--accent-primary);">
                                <h4 style="color: var(--accent-primary); margin-bottom: 8px;">üîÑ ORHunter</h4>
                                <p style="color: var(--text-secondary); margin: 0;">Open Redirect Vulnerability Scanner. Identifies open redirect vulnerabilities in web applications. Useful for SSRF chains and social engineering attacks.</p>
                            </div>
                            <div style="padding: 16px; background: var(--bg-tertiary); border-radius: 8px; border-left: 3px solid var(--accent-primary);">
                                <h4 style="color: var(--accent-primary); margin-bottom: 8px;">üéØ DTOHunter</h4>
                                <p style="color: var(--text-secondary); margin: 0;">Subdomain Takeover Detection Scanner. Detects vulnerable subdomains that can be taken over using fingerprinting from can-i-take-over-xyz.</p>
                            </div>
                        </div>
                        
                        <h3 style="margin-top: 32px; margin-bottom: 16px; color: var(--accent-primary);">Platform Features</h3>
                        <ul style="margin-left: 20px; color: var(--text-secondary); line-height: 2;">
                            <li><strong>Unified Web Dashboard:</strong> Manage all scans from a single interface with real-time monitoring</li>
                            <li><strong>Database-Backed Storage:</strong> All results stored in organized SQLite databases with checkpoint support</li>
                            <li><strong>Multi-Tool Support:</strong> Run multiple tools simultaneously on the same targets</li>
                            <li><strong>Rescan Capabilities:</strong> Reuse collected URLs with new parameters (rescan, recrawl, rediscover)</li>
                            <li><strong>Configuration Management:</strong> Manage API patterns, excluded extensions, and payloads through web UI</li>
                            <li><strong>Subdomain Enumeration:</strong> Optional subdomain discovery using subfinder</li>
                            <li><strong>URL Collection:</strong> Combines Wayback Machine archives and active crawling with katana</li>
                            <li><strong>Authentication Support:</strong> Cookie and custom header support for authenticated scanning</li>
                            <li><strong>Extensible Architecture:</strong> Easy to add new security scanning tools</li>
                        </ul>
                    </div>
                </div>
                
                <div class="card">
                    <div class="card-header">
                        <div class="card-title">Developer</div>
                    </div>
                    <div style="line-height: 1.8;">
                        <p><strong>Author:</strong> <a href="https://abdulaziz-dev.com" target="_blank" style="color: var(--accent-primary); text-decoration: none;">Abdulaziz Saad</a>
                             <a href="https://x.com/b4zb0z" target="_blank" style="color: var(--accent-primary); text-decoration: none;">(@b4zb0z)</a></p>
                        <p><strong>GitHub:</strong> <a href="https://github.com/bigzooooz/BugHunterArsenal" target="_blank" style="color: var(--accent-primary); text-decoration: none;">github.com/bigzooooz/BugHunterArsenal</a></p>
                        <p>BugHunter Arsenal is an open-source project developed to help security researchers and bug bounty hunters with comprehensive security scanning tools.</p>
                    </div>
                </div>
                
                <div class="card">
                    <div class="card-header">
                        <div class="card-title">Support the Project üíñ</div>
                    </div>
                    <div style="line-height: 1.8;">
                        <p>If you find BugHunter Arsenal useful, consider supporting its development:</p>
                        <div style="margin-top: 16px; display: flex; gap: 16px; flex-wrap: wrap;">
                            <a href="https://ko-fi.com/s/cb4c85e80b" target="_blank" class="btn" style="text-decoration: none; display: inline-flex; align-items: center; gap: 6px;">
                                ‚òïÔ∏è Buy Me a Coffee
                            </a>
                            <a href="https://paypal.me/b4zb0z" target="_blank" class="btn" style="text-decoration: none; display: inline-flex; align-items: center; gap: 6px;">
                                üí∏ Support on PayPal
                            </a>
                            <a href="https://github.com/bigzooooz/BugHunterArsenal" target="_blank" class="btn" style="text-decoration: none; display: inline-flex; align-items: center; gap: 6px;">
                                ‚≠ê Star on GitHub
                            </a>
                        </div>
                        <p style="margin-top: 16px; color: var(--text-secondary); font-size: 13px;">
                            Your support helps maintain and improve BugHunter Arsenal. Thank you! üôè
                        </p>
                    </div>
                </div>
                
                <div class="card">
                    <div class="card-header">
                        <div class="card-title">License & Disclaimer</div>
                    </div>
                    <div style="line-height: 1.8; color: var(--text-secondary);">
                        <p><strong>License:</strong> MIT License</p>
                        <p style="margin-top: 12px;"><strong>Disclaimer:</strong> This tool is intended for educational and research purposes only. The author is not responsible for any misuse or damage caused by this tool. Use responsibly and do not violate any laws or policies.</p>
                    </div>
                </div>
            </div>
            
            <!-- New Scan Page -->
            <div id="page-new-scan" class="page-content">
                <div class="page-header">
                    <div class="page-title">Start New Scan</div>
                    <div class="page-subtitle">Configure your scan step by step</div>
                </div>
                
                <!-- Wizard Step 1: Select Scan Types -->
                <div id="wizard-step-1" class="wizard-step">
                    <div class="card">
                        <div class="card-header">
                            <div class="card-title">Step 1: Select What to Scan</div>
                            <div style="font-size: 12px; color: var(--text-secondary);">Choose one or more scan types</div>
                        </div>
                        <div style="padding: 24px;">
                            <div class="scan-type-grid">
                                <div class="scan-type-card" onclick="toggleScanType('subdomain')">
                                    <input type="checkbox" id="scanTypeSubdomain" style="display: none;">
                                    <div class="scan-type-icon">üåê</div>
                                    <div class="scan-type-title">Subdomain Enum</div>
                                    <div class="scan-type-desc">Discover subdomains using subfinder</div>
                                </div>
                                
                                <div class="scan-type-card" onclick="toggleScanType('api')">
                                    <input type="checkbox" id="scanTypeApi" style="display: none;">
                                    <div class="scan-type-icon">üîë</div>
                                    <div class="scan-type-title">API Leaks</div>
                                    <div class="scan-type-desc">Detect API keys from 50+ providers</div>
                                </div>
                                
                                <div class="scan-type-card" onclick="toggleScanType('xss')">
                                    <input type="checkbox" id="scanTypeXss" style="display: none;">
                                    <div class="scan-type-icon">‚ö†Ô∏è</div>
                                    <div class="scan-type-title">XSS Scan</div>
                                    <div class="scan-type-desc">Cross-site scripting vulnerability detection</div>
                                </div>
                                
                                <div class="scan-type-card" onclick="toggleScanType('redirect')">
                                    <input type="checkbox" id="scanTypeRedirect" style="display: none;">
                                    <div class="scan-type-icon">‚Ü™Ô∏è</div>
                                    <div class="scan-type-title">Open Redirects</div>
                                    <div class="scan-type-desc">Identify open redirect vulnerabilities</div>
                                </div>
                                <div class="scan-type-card" onclick="toggleScanType('takeover')">
                                    <input type="checkbox" id="scanTypeTakeover" style="display: none;">
                                    <div class="scan-type-icon">üéØ</div>
                                    <div class="scan-type-title">Subdomain Takeover</div>
                                    <div class="scan-type-desc">Detect subdomain takeover vulnerabilities</div>
                                </div>
                            </div>
                            
                            <div class="card-actions" style="margin-top: 24px; justify-content: flex-end;">
                                <button type="button" class="btn btn-primary" onclick="nextWizardStep()" id="wizardNextBtn" disabled>Next ‚Üí</button>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Wizard Step 2: Configure Scan -->
                <div id="wizard-step-2" class="wizard-step" style="display: none;">
                    <div class="card">
                        <div class="card-header">
                            <div class="card-title">Step 2: Configure Scan</div>
                            <div style="font-size: 12px; color: var(--text-secondary);">Set up your scan parameters</div>
                        </div>
                        <form id="scanForm" onsubmit="startScan(event)">
                            <div style="padding: 24px;">
                                <div class="form-grid">
                                    <div class="form-group">
                                        <label class="form-label">Scan Type</label>
                                        <select class="form-select" id="scanType" onchange="updateScanType()" required>
                                            <option value="domain">Domain Scan (-d)</option>
                                            <option value="file">Domains File (-f)</option>
                                            <option value="urls">URLs File (-l)</option>
                                        </select>
                                    </div>
                                    <div class="form-group" id="targetGroup">
                                        <label class="form-label" id="targetLabel">Target Domain</label>
                                        <input type="text" class="form-input" id="scanTarget" placeholder="example.com" required>
                                        <input type="file" id="scanFile" style="display: none;" accept=".txt">
                                    </div>
                                </div>
                                
                                <div class="form-grid">
                                    <div class="form-group">
                                        <label class="form-checkbox">
                                            <input type="checkbox" id="scanVerbose">
                                            <span>Verbose Output (-v)</span>
                                        </label>
                                    </div>
                                </div>
                                
                                <div class="form-grid">
                                    <div class="form-group">
                                        <label class="form-label">Cookie (optional)</label>
                                        <input type="text" class="form-input" id="scanCookie" placeholder="session=abc123">
                                    </div>
                                    <div class="form-group">
                                        <label class="form-label">X-Request-For (optional)</label>
                                        <input type="text" class="form-input" id="scanXRequestFor" placeholder="HackerOne">
                                    </div>
                                </div>
                                
                                <div class="form-group">
                                    <label class="form-label">Output Directory (optional)</label>
                                    <input type="text" class="form-input" id="scanOutput" placeholder="output">
                                </div>
                                
                                <div class="card-actions" style="margin-top: 24px;">
                                    <button type="button" class="btn" onclick="prevWizardStep()">‚Üê Back</button>
                                    <button type="submit" class="btn btn-primary">Start Scan</button>
                                    <button type="button" class="btn" onclick="resetWizard()">Reset</button>
                                </div>
                            </div>
                        </form>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Edit Finding Modal -->
    <div id="editModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">Edit Finding</div>
                <button class="modal-close" onclick="closeModal('editModal')">&times;</button>
            </div>
            <form id="editForm" onsubmit="saveFinding(event)">
                <input type="hidden" id="editKeyId">
                <div class="form-group">
                    <label class="form-label">Severity</label>
                    <select class="form-select" id="editSeverity" required>
                        <option value="critical">Critical</option>
                        <option value="high">High</option>
                        <option value="medium">Medium</option>
                        <option value="low">Low</option>
                        <option value="info">Info</option>
                    </select>
                </div>
                <div class="form-group">
                    <label class="form-checkbox">
                        <input type="checkbox" id="editFalsePositive">
                        <span>Mark as False Positive</span>
                    </label>
                </div>
                <div class="form-group">
                    <label class="form-checkbox">
                        <input type="checkbox" id="editVerified">
                        <span>Mark as Verified</span>
                    </label>
                </div>
                <div class="form-group">
                    <label class="form-label">Notes</label>
                    <textarea class="form-textarea" id="editNotes" placeholder="Add notes about this finding..."></textarea>
                </div>
                <div class="card-actions">
                    <button type="submit" class="btn btn-primary">Save Changes</button>
                    <button type="button" class="btn" onclick="closeModal('editModal')">Cancel</button>
                </div>
            </form>
        </div>
    </div>
    
    <!-- Scan Output Modal -->
    <div id="scanOutputModal" class="modal">
        <div class="modal-content modal-content-large">
            <div class="modal-header">
                <div class="modal-title" id="scanOutputModalTitle">Scan Output</div>
                <button class="modal-close" onclick="closeScanOutputModal()">&times;</button>
            </div>
            <div class="modal-console" id="scanOutputModalConsole">Loading scan output...</div>
            <div class="card-actions" style="margin-top: 16px;">
                <button class="btn btn-danger btn-stop" onclick="stopScanFromModal()">Stop Scan</button>
                <button class="btn" onclick="closeScanOutputModal()">Close</button>
            </div>
        </div>
    </div>
    
    <!-- Key Occurrences Modal -->
    <div id="keyOccurrencesModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">API Key Occurrences</div>
                <button class="modal-close" onclick="closeKeyOccurrencesModal()">&times;</button>
            </div>
            <div style="padding: 16px;">
                <div style="margin-bottom: 16px;">
                    <div style="font-family: monospace; font-size: 12px; color: var(--text-secondary); word-break: break-all; background: var(--bg-primary); padding: 12px; border-radius: 4px; margin-bottom: 12px;" id="keyOccurrencesModalKeyValue"></div>
                </div>
                <div style="max-height: 400px; overflow-y: auto;" id="keyOccurrencesModalList"></div>
            </div>
            <div class="card-actions" style="margin-top: 16px;">
                <button class="btn" onclick="closeKeyOccurrencesModal()">Close</button>
            </div>
        </div>
    </div>
    
    <script>
        let currentPage = 'dashboard';
        let currentScanId = null;
        let eventSource = null;
        let statsEventSource = null;
        let selectedFindings = new Set();
        let allFindings = [];
        let selectedScans = new Set();
        
        // Request queue to prevent too many concurrent requests
        let requestQueue = {
            active: false,
            pending: []
        };
        
        async function queueRequest(requestFn, priority = false) {
            return new Promise((resolve, reject) => {
                const execute = async () => {
                    try {
                        const result = await requestFn();
                        resolve(result);
                    } catch (error) {
                        reject(error);
                    } finally {
                        requestQueue.active = false;
                        if (requestQueue.pending.length > 0) {
                            const next = requestQueue.pending.shift();
                            requestQueue.active = true;
                            next();
                        }
                    }
                };
                
                if (!requestQueue.active) {
                    requestQueue.active = true;
                    execute();
                } else {
                    if (priority) {
                        requestQueue.pending.unshift(execute);
                    } else {
                        requestQueue.pending.push(execute);
                    }
                }
            });
        }
        
        // Shared scan data cache to avoid duplicate requests
        let scanDataCache = {
            data: null,
            timestamp: 0,
            ttl: 5000, // 5 second cache - increased to reduce requests
            fetching: false,
            waiting: [],
            lastFetchTime: 0,
            minInterval: 2000  // Minimum 2 seconds between requests
        };
        
        // Debounce timer for scan reloads
        let scanReloadDebounceTimer = null;
        
        async function fetchScanData(forceRefresh = false) {
            const now = Date.now();
            
            // Enforce minimum interval between requests - CRITICAL to prevent excessive requests
            const timeSinceLastFetch = now - scanDataCache.lastFetchTime;
            if (timeSinceLastFetch < scanDataCache.minInterval) {
                // Always return cached data if available when within minimum interval
                if (scanDataCache.data && !forceRefresh) {
                    return scanDataCache.data;
                }
                // If forcing refresh but too soon, wait
                if (forceRefresh) {
                    const waitTime = scanDataCache.minInterval - timeSinceLastFetch;
                    await new Promise(resolve => setTimeout(resolve, waitTime));
                }
            }
            
            // Use cache if data is fresh and not forcing refresh
            if (!forceRefresh && scanDataCache.data && (now - scanDataCache.timestamp) < scanDataCache.ttl) {
                return scanDataCache.data;
            }
            
            // If already fetching, wait for that request instead of making a new one
            if (scanDataCache.fetching) {
                return new Promise((resolve, reject) => {
                    scanDataCache.waiting.push({resolve, reject});
                });
            }
            
            // Fetch fresh data - update lastFetchTime FIRST to prevent concurrent requests
            scanDataCache.lastFetchTime = Date.now();
            scanDataCache.fetching = true;
            try {
                const data = await queueRequest(async () => {
                    const response = await fetch('/api/scans');
                    if (!response.ok) {
                        throw new Error('Failed to fetch scans');
                    }
                    return await response.json();
                });
                
                scanDataCache.data = data;
                scanDataCache.timestamp = Date.now();
                
                // Resolve all waiting promises
                scanDataCache.waiting.forEach(waiter => waiter.resolve(data));
                scanDataCache.waiting = [];
                
                return data;
            } catch (error) {
                // Reject all waiting promises
                scanDataCache.waiting.forEach(waiter => waiter.reject(error));
                scanDataCache.waiting = [];
                throw error;
            } finally {
                scanDataCache.fetching = false;
            }
        }
        
        // Debounced scan reload function
        function debouncedReloadScans() {
            if (scanReloadDebounceTimer) {
                clearTimeout(scanReloadDebounceTimer);
            }
            scanReloadDebounceTimer = setTimeout(() => {
                if (currentPage === 'scans') {
                    loadScans();
                }
                if (currentPage === 'dashboard') {
                    loadRunningScansDashboard();
                }
            }, 2000); // Wait 2 seconds before reloading
        }
        
        // Logs functions
        let logsRefreshInterval = null;
        
        async function loadLogs() {
            try {
                const lines = parseInt(document.getElementById('logsLinesInput')?.value || 1000);
                const response = await fetch(`/api/logs?lines=${lines}`);
                
                if (!response.ok) {
                    throw new Error('Failed to load logs');
                }
                
                const data = await response.json();
                const logsContent = document.getElementById('logsContent');
                const logsInfo = document.getElementById('logsInfo');
                
                if (logsContent) {
                    if (data.logs && data.logs.length > 0) {
                        // Format logs with color coding
                        let html = '';
                        data.logs.forEach(line => {
                            let color = 'var(--text-secondary)';
                            let bgColor = 'transparent';
                            
                            // Color code by log level
                            if (line.includes('ERROR') || line.includes('CRITICAL')) {
                                color = 'var(--critical)';
                                bgColor = 'rgba(255, 59, 48, 0.1)';
                            } else if (line.includes('WARNING') || line.includes('WARN')) {
                                color = 'var(--high)';
                                bgColor = 'rgba(255, 149, 0, 0.1)';
                            } else if (line.includes('INFO')) {
                                color = 'var(--accent-primary)';
                            } else if (line.includes('DEBUG')) {
                                color = 'var(--text-muted)';
                            }
                            
                            html += `<div style="color: ${color}; background: ${bgColor}; padding: 2px 4px; margin: 1px 0; border-left: 2px solid ${color}; padding-left: 8px;">${escapeHtml(line)}</div>`;
                        });
                        logsContent.innerHTML = html;
                        // Scroll to bottom
                        logsContent.scrollTop = logsContent.scrollHeight;
                    } else {
                        logsContent.innerHTML = '<div style="text-align: center; color: var(--text-muted); padding: 20px;">No log entries found</div>';
                    }
                }
                
                if (logsInfo) {
                    const fileSizeMB = (data.file_size / (1024 * 1024)).toFixed(2);
                    logsInfo.innerHTML = `Showing last ${data.lines_returned || 0} of ${data.total_lines || 0} lines | File size: ${fileSizeMB} MB`;
                }
            } catch (error) {
                console.error('Error loading logs:', error);
                const logsContent = document.getElementById('logsContent');
                if (logsContent) {
                    logsContent.innerHTML = `<div style="color: var(--critical); padding: 20px;">Error loading logs: ${error.message}</div>`;
                }
            }
        }
        
        async function clearLogs() {
            if (!confirm('Are you sure you want to clear all server logs? This action cannot be undone.')) {
                return;
            }
            
            try {
                const response = await fetch('/api/logs', {
                    method: 'DELETE'
                });
                
                if (!response.ok) {
                    throw new Error('Failed to clear logs');
                }
                
                // Reload logs after clearing
                await loadLogs();
                
                // Show success message
                const logsInfo = document.getElementById('logsInfo');
                if (logsInfo) {
                    logsInfo.innerHTML = '<span style="color: var(--success);">‚úì Logs cleared successfully</span>';
                    setTimeout(() => loadLogs(), 2000);
                }
            } catch (error) {
                console.error('Error clearing logs:', error);
                alert('Error clearing logs: ' + error.message);
            }
        }
        
        // Auto-refresh logs every 5 seconds when on logs page
        function startLogsAutoRefresh() {
            if (logsRefreshInterval) {
                clearInterval(logsRefreshInterval);
            }
            if (currentPage === 'logs') {
                logsRefreshInterval = setInterval(() => {
                    if (currentPage === 'logs') {
                        loadLogs();
                    }
                }, 5000);
            }
        }
        
        function stopLogsAutoRefresh() {
            if (logsRefreshInterval) {
                clearInterval(logsRefreshInterval);
                logsRefreshInterval = null;
            }
        }
        
        // Pagination state
        let paginationState = {
            findings: { currentPage: 1, rowsPerPage: 50 },
            targets: { currentPage: 1, rowsPerPage: 50 },
            scans: { currentPage: 1, rowsPerPage: 50 },
            recentFindings: { currentPage: 1, rowsPerPage: 5 }
        };
        
        let currentTargetDomain = null;
        
        function toggleDrawer() {
            document.body.classList.toggle('drawer-open');
        }
        
        function closeDrawer() {
            document.body.classList.remove('drawer-open');
        }
        
        function showPage(page) {
            closeDrawer();
            // Stop logs auto-refresh if leaving logs page
            if (currentPage === 'logs' && page !== 'logs') {
                stopLogsAutoRefresh();
            }
            
            document.querySelectorAll('.page-content').forEach(p => p.classList.remove('active'));
            document.querySelectorAll('.nav-item').forEach(n => n.classList.remove('active'));
            document.getElementById(`page-${page}`).classList.add('active');
            currentPage = page;
            
            if (page === 'findings') {
                loadFindings();
            } else if (page === 'scans') {
                loadScans();
            } else if (page === 'dashboard') {
                loadDashboard();
                loadRunningScansDashboard();
            } else if (page === 'targets') {
                loadTargets();
            } else if (page === 'logs') {
                loadLogs();
                startLogsAutoRefresh();
            } else if (page === 'target-detail') {
                if (currentTargetDomain) {
                    loadTargetDetail(currentTargetDomain);
                }
            } else if (page === 'settings') {
                loadConfigFile();
            } else if (page === 'new-scan') {
                resetWizard();
            }
            // About page doesn't need any data loading
        }
        
        async function viewTarget(domain) {
            currentTargetDomain = domain;
            showPage('target-detail');
        }
        
        async function loadTargetDetail(domain) {
            try {
                const encodedDomain = encodeURIComponent(domain);
                // Load summary first (lightweight)
                const summaryResponse = await fetch(`/api/targets/${encodedDomain}/summary`);
                
                if (!summaryResponse.ok) {
                    const error = await summaryResponse.json();
                    alert('Failed to load target: ' + (error.error || 'Unknown error'));
                    showPage('targets');
                    return;
                }
                
                const summaryData = await summaryResponse.json();
                
                // Update page title
                document.getElementById('targetDetailTitle').textContent = summaryData.domain;
                document.getElementById('targetDetailSubtitle').textContent = `${summaryData.total_findings} findings ‚Ä¢ ${summaryData.total_urls} URLs ‚Ä¢ ${summaryData.total_subdomains} subdomains`;
                
                let html = '';
                const domainSafe = domain.replace(/[^a-zA-Z0-9]/g, '_');
                
                // APIs Section - only show if there are findings
                if (summaryData.total_findings > 0) {
                    const apisCardId = `apis-card-${domainSafe}`;
                    html += `
                        <div class="card" style="margin-bottom: 24px;">
                            <div class="card-header" onclick="toggleTargetSection('${apisCardId}', '${encodedDomain}')" style="cursor: pointer;">
                                <div class="card-title" style="display: flex; align-items: center; gap: 12px;">
                                    <span class="toggle-icon" id="${apisCardId}-icon">‚ñ∂</span>
                                    <span>üîë APIs (${summaryData.total_findings} finding${summaryData.total_findings !== 1 ? 's' : ''})</span>
                                </div>
                            </div>
                            <div class="target-section-content" id="${apisCardId}" style="display: none; padding: 16px;">
                                <div style="text-align: center; padding: 20px; color: var(--text-secondary);">
                                    <div class="spinner" style="width: 24px; height: 24px; border-width: 2px; margin: 0 auto 8px;"></div>
                                    Loading findings...
                                </div>
                            </div>
                        </div>
                    </div>
                `;
                }
                
                // URLs Section - only show if there are URLs
                if (summaryData.total_urls > 0) {
                    const urlsCardId = `urls-card-${domainSafe}`;
                    html += `
                        <div class="card" style="margin-bottom: 24px;">
                            <div class="card-header" onclick="toggleTargetSection('${urlsCardId}', '${encodedDomain}')" style="cursor: pointer;">
                                <div class="card-title" style="display: flex; align-items: center; gap: 12px;">
                                    <span class="toggle-icon" id="${urlsCardId}-icon">‚ñ∂</span>
                                    <span>üîó URLs (${summaryData.total_urls} URL${summaryData.total_urls !== 1 ? 's' : ''})</span>
                                </div>
                            </div>
                            <div class="target-section-content" id="${urlsCardId}" style="display: none; padding: 16px;">
                                <div style="text-align: center; padding: 20px; color: var(--text-secondary);">
                                    <div class="spinner" style="width: 24px; height: 24px; border-width: 2px; margin: 0 auto 8px;"></div>
                                    Loading URLs...
                                </div>
                            </div>
                        </div>
                    </div>
                `;
                }
                
                // SUBS Section - only show if there are subdomains
                if (summaryData.total_subdomains > 0) {
                    const subsCardId = `subs-card-${domainSafe}`;
                    html += `
                        <div class="card" style="margin-bottom: 24px;">
                            <div class="card-header" onclick="toggleTargetSection('${subsCardId}', '${encodedDomain}')" style="cursor: pointer;">
                                <div class="card-title" style="display: flex; align-items: center; gap: 12px;">
                                    <span class="toggle-icon" id="${subsCardId}-icon">‚ñ∂</span>
                                    <span>üåê SUBS (${summaryData.total_subdomains} subdomain${summaryData.total_subdomains !== 1 ? 's' : ''})</span>
                                </div>
                            </div>
                            <div class="target-section-content" id="${subsCardId}" style="display: none; padding: 16px;">
                                <div style="text-align: center; padding: 20px; color: var(--text-secondary);">
                                    <div class="spinner" style="width: 24px; height: 24px; border-width: 2px; margin: 0 auto 8px;"></div>
                                    Loading subdomains...
                                </div>
                            </div>
                        </div>
                    </div>
                `;
                }
                
                document.getElementById('targetDetailContent').innerHTML = html;
                
                // Store domain for section loading
                window.currentTargetDomain = encodedDomain;
            } catch (error) {
                console.error('Error loading target detail:', error);
                alert('Error loading target: ' + error.message);
                showPage('targets');
            }
        }
        
        async function loadTargetSection(sectionId, domain) {
            const sectionEl = document.getElementById(sectionId);
            if (!sectionEl) return;
            
            // Check if already loaded (has data, not just loading spinner)
            if (sectionEl.dataset.loaded === 'true') return;
            
            try {
                let endpoint = '';
                if (sectionId.includes('apis-card')) {
                    endpoint = `/api/targets/${domain}/findings`;
                } else if (sectionId.includes('urls-card')) {
                    endpoint = `/api/targets/${domain}/urls`;
                } else if (sectionId.includes('subs-card')) {
                    endpoint = `/api/targets/${domain}/subdomains`;
                } else {
                    return;
                }
                
                const response = await fetch(endpoint);
                if (!response.ok) {
                    sectionEl.innerHTML = `<div style="color: var(--critical); padding: 20px;">Error loading section: ${(await response.json()).error || 'Unknown error'}</div>`;
                    return;
                }
                
                const data = await response.json();
                let contentHtml = '';
                
                if (sectionId.includes('apis-card')) {
                    // Group findings by provider
                    const findingsByProvider = {};
                    (data.findings || []).forEach(finding => {
                        if (!findingsByProvider[finding.provider]) {
                            findingsByProvider[finding.provider] = [];
                        }
                        findingsByProvider[finding.provider].push(finding);
                    });
                    
                    const domainSafe = decodeURIComponent(domain).replace(/[^a-zA-Z0-9]/g, '_');
                    contentHtml = Object.keys(findingsByProvider).sort().map(provider => {
                        const providerFindings = findingsByProvider[provider];
                        const providerId = `provider-${domainSafe}-${provider.replace(/[^a-zA-Z0-9]/g, '_')}`;
                        return `
                            <div style="margin-bottom: 16px; background: var(--bg-secondary); border-radius: 8px; border-left: 4px solid var(--accent-primary);">
                                <div class="target-section-header" onclick="toggleTargetSection('${providerId}')" style="cursor: pointer; padding: 12px; display: flex; align-items: center; justify-content: space-between;">
                                    <div style="display: flex; align-items: center; gap: 12px;">
                                        <span class="toggle-icon" id="${providerId}-icon">‚ñ∂</span>
                                        <span style="font-size: 16px; font-weight: 600; color: var(--accent-primary);">
                                            ${escapeHtml(provider)} <span style="color: var(--text-secondary); font-weight: normal;">(${providerFindings.length} key${providerFindings.length !== 1 ? 's' : ''})</span>
                                        </span>
                                    </div>
                                </div>
                                <div class="target-section-content" id="${providerId}" style="display: none; padding: 12px; padding-top: 0;">
                                    ${(() => {
                                        const groupedByKey = {};
                                        providerFindings.forEach(key => {
                                            const keyValue = key.key_value;
                                            if (!groupedByKey[keyValue]) {
                                                groupedByKey[keyValue] = [];
                                            }
                                            groupedByKey[keyValue].push(key);
                                        });
                                        
                                        return Object.keys(groupedByKey).map(keyValue => {
                                            const occurrences = groupedByKey[keyValue];
                                            const firstKey = occurrences[0];
                                            const severity = firstKey.severity || 'medium';
                                            const validation = firstKey.validation_status || 'manual';
                                            const validationIcon = validation === 'valid' ? '‚úì' : (validation === 'invalid' ? '‚úó' : '?');
                                            const validationColor = validation === 'valid' ? 'var(--success)' : (validation === 'invalid' ? 'var(--danger)' : 'var(--warning)');
                                            const severityColor = severity === 'critical' ? 'var(--critical)' : 
                                                                  severity === 'high' ? 'var(--high)' : 
                                                                  severity === 'medium' ? 'var(--medium)' : 
                                                                  severity === 'low' ? 'var(--low)' : 'var(--info-severity)';
                                            
                                            const uniqueUrls = [...new Set(occurrences.map(k => k.url).filter(Boolean))];
                                            const occurrencesCount = occurrences.length;
                                            const modalId = `key-occurrences-${domainSafe}-${provider.replace(/[^a-zA-Z0-9]/g, '_')}-${keyValue.replace(/[^a-zA-Z0-9]/g, '_').substring(0, 50)}`;
                                            const occurrencesData = JSON.stringify(occurrences.map(k => ({
                                                url: k.url,
                                                key_id: k.key_id,
                                                severity: k.severity,
                                                verified: k.verified,
                                                false_positive: k.false_positive,
                                                validation_status: k.validation_status,
                                                notes: k.notes || '',
                                                key_value: k.key_value
                                            }))).replace(/"/g, '&quot;');
                                            
                                            return `
                                                <div style="background: var(--bg-tertiary); padding: 12px; border-radius: 6px; margin-bottom: 12px; border-left: 3px solid ${severityColor};">
                                                    <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px;">
                                                        <div style="display: flex; align-items: center; gap: 8px; flex-wrap: wrap;">
                                                            <span class="severity-badge severity-${severity}">${severity}</span>
                                                            <span style="color: ${validationColor}; font-size: 12px;">${validationIcon} ${validation.toUpperCase()}</span>
                                                            ${firstKey.verified ? '<span style="color: var(--success); font-size: 11px;">‚úì Verified</span>' : ''}
                                                            ${firstKey.false_positive ? '<span style="color: var(--text-muted); font-size: 11px;">‚ö† False Positive</span>' : ''}
                                                            ${uniqueUrls.length > 0 ? `<a href="${escapeHtml(uniqueUrls[0])}" target="_blank" style="font-size: 11px; color: var(--accent-secondary); text-decoration: none;">${escapeHtml(uniqueUrls[0])}</a>` : ''}
                                                            ${occurrencesCount > 1 ? `<span style="font-size: 11px; color: var(--accent-primary); cursor: pointer; text-decoration: underline;" onclick="showKeyOccurrencesModal('${modalId}', ${occurrencesData})">(${occurrencesCount} occurrences)</span>` : ''}
                                                        </div>
                                                        <div style="display: flex; gap: 4px;">
                                                            <button class="btn" onclick="editFinding(${firstKey.key_id})" style="font-size: 11px; padding: 4px 8px;">Edit</button>
                                                            <button class="btn btn-danger" onclick="deleteFinding(${firstKey.key_id})" style="font-size: 11px; padding: 4px 8px;">Delete</button>
                                                        </div>
                                                    </div>
                                                    <div style="font-family: monospace; font-size: 11px; color: var(--text-secondary); word-break: break-all; background: var(--bg-primary); padding: 8px; border-radius: 4px;">
                                                        ${escapeHtml(keyValue)}
                                                    </div>
                                                    ${firstKey.notes ? `<div style="font-size: 11px; color: var(--text-secondary); margin-top: 6px; font-style: italic;">${escapeHtml(firstKey.notes)}</div>` : ''}
                                                </div>
                                            `;
                                        }).join('');
                                    })()}
                                </div>
                            </div>
                        `;
                    }).join('');
                } else if (sectionId.includes('urls-card')) {
                    contentHtml = (data.urls || []).map(url => `
                        <div style="padding: 10px; background: var(--bg-secondary); border-radius: 6px; margin-bottom: 8px; display: flex; align-items: center; justify-content: space-between;">
                            <a href="${escapeHtml(url.url)}" target="_blank" class="url-link">${escapeHtml(url.url)}</a>
                            ${url.status_code ? `<span style="font-size: 11px; color: var(--text-muted); margin-left: 8px;">[${url.status_code}]</span>` : ''}
                        </div>
                    `).join('');
                } else if (sectionId.includes('subs-card')) {
                    contentHtml = (data.subdomains || []).map(subdomain => `
                        <div style="padding: 10px; background: var(--bg-secondary); border-radius: 6px; margin-bottom: 8px;">
                            <strong style="color: var(--accent-primary);">${escapeHtml(subdomain)}</strong>
                        </div>
                    `).join('');
                }
                
                sectionEl.innerHTML = contentHtml;
                sectionEl.dataset.loaded = 'true';
            } catch (error) {
                console.error('Error loading section:', error);
                sectionEl.innerHTML = `<div style="color: var(--critical); padding: 20px;">Error loading section: ${error.message}</div>`;
            }
        }
        
        function toggleTargetSection(sectionId, domain) {
            const section = document.getElementById(sectionId);
            const icon = document.getElementById(`${sectionId}-icon`);
            
            if (section && icon) {
                const isVisible = section.style.display !== 'none';
                section.style.display = isVisible ? 'none' : 'block';
                icon.textContent = isVisible ? '‚ñ∂' : '‚ñº';
                icon.classList.toggle('open');
                
                // Load section data on first expand
                if (!isVisible && domain && section.dataset.loaded !== 'true') {
                    loadTargetSection(sectionId, domain);
                }
            }
        }
        
        function showCreateTargetModal() {
            const domain = prompt('Enter target domain:');
            if (!domain || !domain.trim()) return;
            
            createTarget(domain.trim());
        }
        
        async function createTarget(domain) {
            try {
                const response = await fetch('/api/targets', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({domain: domain})
                });
                
                if (!response.ok) {
                    const error = await response.json();
                    alert('Failed to create target: ' + (error.error || 'Unknown error'));
                    return;
                }
                
                loadTargets();
            } catch (error) {
                alert('Error creating target: ' + error.message);
            }
        }
        
        function showRenameTargetModal() {
            if (!currentTargetDomain) return;
            
            const newDomain = prompt('Enter new domain name:', currentTargetDomain);
            if (!newDomain || !newDomain.trim() || newDomain.trim() === currentTargetDomain) return;
            
            renameTarget(currentTargetDomain, newDomain.trim());
        }
        
        async function renameTarget(oldDomain, newDomain) {
            try {
                const encodedDomain = encodeURIComponent(oldDomain);
                const response = await fetch(`/api/targets/${encodedDomain}`, {
                    method: 'PUT',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({domain: newDomain})
                });
                
                if (!response.ok) {
                    const error = await response.json();
                    alert('Failed to rename target: ' + (error.error || 'Unknown error'));
                    return;
                }
                
                currentTargetDomain = newDomain;
                loadTargetDetail(newDomain);
                loadTargets();
            } catch (error) {
                alert('Error renaming target: ' + error.message);
            }
        }
        
        async function deleteCurrentTarget() {
            if (!currentTargetDomain) return;
            
            if (!confirm(`‚ö†Ô∏è WARNING: This will permanently delete target "${currentTargetDomain}" and ALL associated data:\n\n‚Ä¢ All scan results for this target\n‚Ä¢ All subdomains for this target\n‚Ä¢ All URLs found for this target\n‚Ä¢ All API keys found for this target\n\nThis action cannot be undone!\n\nAre you sure you want to proceed?`)) {
                return;
            }
            
            if (!confirm(`Last chance! Are you absolutely sure you want to delete "${currentTargetDomain}" and purge all its data?`)) {
                return;
            }
            
            try {
                const encodedDomain = encodeURIComponent(currentTargetDomain);
                const response = await fetch(`/api/scans/by-domain/${encodedDomain}`, {
                    method: 'DELETE'
                });
                
                if (!response.ok) {
                    const error = await response.json();
                    alert('Failed to delete target: ' + (error.error || 'Unknown error'));
                    return;
                }
                
                currentTargetDomain = null;
                showPage('targets');
                loadTargets();
            } catch (error) {
                alert('Error deleting target: ' + error.message);
            }
        }
        
        async function rescanTarget() {
            if (!currentTargetDomain) return;
            
            try {
                const encodedDomain = encodeURIComponent(currentTargetDomain);
                const response = await fetch(`/api/targets/${encodedDomain}/scan-info`, {
                    method: 'GET'
                });
                
                if (!response.ok) {
                    const error = await response.json();
                    alert('Failed to get scan info: ' + (error.error || 'Unknown error'));
                    return;
                }
                
                const scanInfo = await response.json();
                
                // Enable rescan mode and store target domain
                rescanMode = true;
                rescanTargetDomain = currentTargetDomain;
                
                // Open wizard and pre-fill with existing parameters
                showPage('new-scan');
                
                // Pre-fill the wizard after a short delay to ensure DOM is ready
                setTimeout(() => {
                    setupRescanWizard(scanInfo);
                }, 100);
                
            } catch (error) {
                alert('Error getting scan info: ' + error.message);
            }
        }
        
        function setupRescanWizard(scanInfo) {
            // Reset wizard first
            resetWizard();
            
            // Hide subdomain enum card (we're reusing URLs, so no need to enumerate)
            const subdomainCard = document.querySelector('.scan-type-card[onclick="toggleScanType(\'subdomain\')"]');
            if (subdomainCard) {
                subdomainCard.style.display = 'none';
            }
            
            // Update wizard title
            const wizardTitle = document.querySelector('#page-new-scan .page-title');
            if (wizardTitle) {
                wizardTitle.textContent = 'Re-scan URLs';
            }
            const wizardSubtitle = document.querySelector('#page-new-scan .page-subtitle');
            if (wizardSubtitle) {
                wizardSubtitle.textContent = 'Configure scan parameters (will reuse existing URLs)';
            }
            
            // Pre-select tools based on options (if they have tools in the options)
            const tools = scanInfo.options?.tools || ['keyhunter'];
            if (Array.isArray(tools)) {
                tools.forEach(tool => {
                    if (tool === 'keyhunter') {
                        toggleScanType('api');
                    } else if (tool === 'xsshunter' || tool === 'xss') {
                        toggleScanType('xss');
                    } else if (tool === 'openredirect' || tool === 'redirect') {
                        toggleScanType('redirect');
                    } else if (tool === 'dtohunter' || tool === 'takeover') {
                        toggleScanType('takeover');
                    }
                });
            }
            
            // Pre-fill step 2 form fields
            setTimeout(() => {
                // Set scan type (should always be 'domain' for rescan)
                const scanTypeSelect = document.getElementById('scanType');
                if (scanTypeSelect) {
                    scanTypeSelect.value = scanInfo.scan_type || 'domain';
                    scanTypeSelect.disabled = true; // Disable changing scan type in rescan mode
                    updateScanType();
                }
                
                // Set target (read-only, since we're rescanning the same target)
                const scanTarget = document.getElementById('scanTarget');
                if (scanTarget) {
                    scanTarget.value = scanInfo.target || rescanTargetDomain;
                    scanTarget.readOnly = true;
                    scanTarget.style.backgroundColor = '#f5f5f5';
                    scanTarget.style.cursor = 'not-allowed';
                }
                
                // Pre-fill options
                const options = scanInfo.options || {};
                
                const scanVerbose = document.getElementById('scanVerbose');
                if (scanVerbose) {
                    scanVerbose.checked = options.verbose || false;
                }
                
                const scanCookie = document.getElementById('scanCookie');
                if (scanCookie && options.cookie) {
                    scanCookie.value = options.cookie;
                }
                
                const scanXRequestFor = document.getElementById('scanXRequestFor');
                if (scanXRequestFor && options.x_request_for) {
                    scanXRequestFor.value = options.x_request_for;
                }
                
                const scanOutput = document.getElementById('scanOutput');
                if (scanOutput && scanInfo.output_dir) {
                    scanOutput.value = scanInfo.output_dir;
                }
                
                // Skip to step 2 (since we already selected tools, user can change if needed)
                document.getElementById('wizard-step-1').style.display = 'none';
                document.getElementById('wizard-step-2').style.display = 'block';
            }, 50);
        }
        
        async function recrawlTarget() {
            if (!currentTargetDomain) return;
            
            if (!confirm(`Re-crawl URLs for "${currentTargetDomain}"?\n\nThis will re-collect URLs from existing subdomains using the same scan parameters.`)) {
                return;
            }
            
            try {
                const encodedDomain = encodeURIComponent(currentTargetDomain);
                const response = await fetch(`/api/targets/${encodedDomain}/recrawl`, {
                    method: 'POST'
                });
                
                if (!response.ok) {
                    const error = await response.json();
                    alert('Failed to re-crawl target: ' + (error.error || 'Unknown error'));
                    return;
                }
                
                const data = await response.json();
                currentScanId = data.scan_id;
                
                showPage('scans');
                watchScan(currentScanId);
                debouncedReloadScans();
            } catch (error) {
                alert('Error re-crawling target: ' + error.message);
            }
        }
        
        async function rediscoverTarget() {
            if (!currentTargetDomain) return;
            
            if (!confirm(`Re-discover "${currentTargetDomain}"?\n\nThis will start a fresh scan: re-discover subdomains and crawl URLs using the same scan parameters.\n\nExisting data will be cleared.`)) {
                return;
            }
            
            try {
                const encodedDomain = encodeURIComponent(currentTargetDomain);
                const response = await fetch(`/api/targets/${encodedDomain}/rediscover`, {
                    method: 'POST'
                });
                
                if (!response.ok) {
                    const error = await response.json();
                    alert('Failed to re-discover target: ' + (error.error || 'Unknown error'));
                    return;
                }
                
                const data = await response.json();
                currentScanId = data.scan_id;
                
                showPage('scans');
                watchScan(currentScanId);
                loadScans();
                loadRunningScansDashboard();
            } catch (error) {
                alert('Error re-discovering target: ' + error.message);
            }
        }
        
        function updateScanType() {
            const scanType = document.getElementById('scanType').value;
            const targetLabel = document.getElementById('targetLabel');
            const scanTarget = document.getElementById('scanTarget');
            const scanFile = document.getElementById('scanFile');
            
            if (scanType === 'domain') {
                targetLabel.textContent = 'Target Domain';
                scanTarget.type = 'text';
                scanTarget.placeholder = 'example.com';
                scanTarget.style.display = 'block';
                scanFile.style.display = 'none';
            } else {
                targetLabel.textContent = scanType === 'file' ? 'Domains File' : 'URLs File';
                scanTarget.type = 'file';
                scanTarget.style.display = 'block';
                scanFile.style.display = 'none';
            }
        }
        
        // Wizard functions
        let selectedScanTypes = new Set();
        let rescanMode = false;
        let rescanTargetDomain = null;
        
        function toggleScanType(type) {
            const checkboxId = `scanType${type.charAt(0).toUpperCase() + type.slice(1)}`;
            const checkbox = document.getElementById(checkboxId);
            const card = checkbox.closest('.scan-type-card');
            
            if (selectedScanTypes.has(type)) {
                selectedScanTypes.delete(type);
                checkbox.checked = false;
                card.classList.remove('selected');
            } else {
                selectedScanTypes.add(type);
                checkbox.checked = true;
                card.classList.add('selected');
            }
            
            // Enable/disable Next button based on selection
            const nextBtn = document.getElementById('wizardNextBtn');
            if (nextBtn) {
                nextBtn.disabled = selectedScanTypes.size === 0;
            }
        }
        
        function nextWizardStep() {
            if (selectedScanTypes.size === 0) {
                alert('Please select at least one scan type');
                return;
            }
            
            // Hide step 1, show step 2
            document.getElementById('wizard-step-1').style.display = 'none';
            document.getElementById('wizard-step-2').style.display = 'block';
        }
        
        function prevWizardStep() {
            // Hide step 2, show step 1
            document.getElementById('wizard-step-2').style.display = 'none';
            document.getElementById('wizard-step-1').style.display = 'block';
        }
        
        function resetWizard() {
            // Reset scan type selections
            selectedScanTypes.clear();
            document.querySelectorAll('.scan-type-card').forEach(card => {
                card.classList.remove('selected');
            });
            document.querySelectorAll('input[type="checkbox"][id^="scanType"]').forEach(checkbox => {
                checkbox.checked = false;
            });
            
            // Reset form
            const form = document.getElementById('scanForm');
            if (form) {
                form.reset();
            }
            
            // Reset to step 1
            document.getElementById('wizard-step-2').style.display = 'none';
            document.getElementById('wizard-step-1').style.display = 'block';
            
            // Disable Next button
            const nextBtn = document.getElementById('wizardNextBtn');
            if (nextBtn) {
                nextBtn.disabled = true;
            }
        }
        
        async function startScan(event) {
            event.preventDefault();
            
            const scanType = document.getElementById('scanType').value;
            const scanTarget = document.getElementById('scanTarget');
            const scanVerbose = document.getElementById('scanVerbose').checked;
            // Subdomain option is determined by step 1 selection
            // If "subdomain" is selected, subdomains are enabled (no_subs = false)
            // If "subdomain" is NOT selected, subdomains are disabled (no_subs = true)
            const subdomainEnabled = selectedScanTypes.has('subdomain');
            const scanNoSubs = !subdomainEnabled;
            const scanCookie = document.getElementById('scanCookie').value;
            const scanXRequestFor = document.getElementById('scanXRequestFor').value;
            const scanOutput = document.getElementById('scanOutput').value;
            
            let target = '';
            if (scanType === 'domain') {
                target = scanTarget.value.trim();
            } else {
                if (scanTarget.type === 'file' && scanTarget.files && scanTarget.files.length > 0) {
                    const formData = new FormData();
                    formData.append('file', scanTarget.files[0]);
                    formData.append('type', scanType);
                    
                    try {
                        const uploadResponse = await fetch('/api/upload', {
                            method: 'POST',
                            body: formData
                        });
                        
                        if (!uploadResponse.ok) {
                            const error = await uploadResponse.json();
                            alert('Failed to upload file: ' + (error.error || 'Unknown error'));
                            return;
                        }
                        
                        const uploadData = await uploadResponse.json();
                        target = uploadData.file_path;
                    } catch (error) {
                        alert('Error uploading file: ' + error.message);
                        return;
                    }
                } else {
                    target = scanTarget.value.trim();
                }
            }
            
            if (!target) {
                alert('Please provide a target');
                return;
            }
            
            // Determine which tools to run based on step 1 selection
            const tools = [];
            if (selectedScanTypes.has('api')) {
                tools.push('keyhunter');
            }
            if (selectedScanTypes.has('xss')) {
                tools.push('xsshunter');
            }
            if (selectedScanTypes.has('redirect')) {
                tools.push('openredirect');
            }
            if (selectedScanTypes.has('takeover')) {
                tools.push('dtohunter');
            }
            // If no tools selected, default to keyhunter
            if (tools.length === 0) {
                tools.push('keyhunter');
            }
            
            const options = {
                verbose: scanVerbose,
                no_subs: scanNoSubs,
                cookie: scanCookie || undefined,
                x_request_for: scanXRequestFor || undefined,
                output: scanOutput || undefined,
                tools: tools
            };
            
            // If in rescan mode, add reuse_urls flag and always disable subs
            if (rescanMode) {
                options.reuse_urls = true;
                options.no_subs = true; // Always skip subdomain enum when rescanning
            }
            
            try {
                // In rescan mode, skip the existing scan check and go directly to starting scan
                // In normal mode, check for existing scan (don't pass restart parameter)
                if (rescanMode) {
                    // Rescan mode: reset URLs and start scan directly
                    await startRescanScan(scanType, target, options);
                    return;
                }
                
                // First request - check for existing scan (don't pass restart parameter)
                const response = await fetch('/api/scans', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({type: scanType, target: target, options: options})
                });
                
                if (!response.ok) {
                    let errorMessage = 'Unknown error';
                    try {
                        const error = await response.json();
                        errorMessage = error.error || error.message || 'Unknown error';
                    } catch (e) {
                        errorMessage = `HTTP ${response.status}: ${response.statusText}`;
                    }
                    alert('Failed to start scan: ' + errorMessage);
                    return;
                }
                
                const data = await response.json();
                
                // Check if existing scan was found
                if (data.existing_scan) {
                    const existingMsg = `Existing scan found for: ${data.domain}\n\n` +
                        `Status: ${data.status}\n` +
                        `Checkpoint: ${data.checkpoint || 'N/A'}\n` +
                        `Started: ${new Date(data.start_time).toLocaleString()}\n\n` +
                        `Choose an option:\n` +
                        `[1] Resume existing scan from last checkpoint\n` +
                        `[2] Start fresh (delete old scan and create new)\n` +
                        `[Cancel] - Cancel this action`;
                    
                    const choice = prompt(existingMsg + '\n\nEnter 1 to Resume, 2 to Restart, or Cancel to abort:');
                    
                    if (choice === '1') {
                        // User chose Resume - start scan normally (will auto-resume)
                        await startScanWithRestart(scanType, target, options, false);
                    } else if (choice === '2') {
                        // User wants to restart - ask confirmation
                        const confirmRestart = confirm('Are you sure you want to delete the existing scan and start fresh?\n\nThis action cannot be undone.');
                        if (confirmRestart) {
                            await startScanWithRestart(scanType, target, options, true);
                        }
                    }
                    // If user canceled or entered invalid choice, do nothing
                    return;
                }
                
                // No existing scan, proceed normally
                currentScanId = data.scan_id;
                showPage('scans');
                watchScan(currentScanId);
                loadScans();
            } catch (error) {
                console.error('Scan start error:', error);
                let errorMessage = error.message || 'Unknown error';
                if (error.message === 'Failed to fetch') {
                    errorMessage = 'Failed to connect to server. Please make sure the BugHunter Arsenal server is running on http://127.0.0.1:5000';
                }
                alert('Error starting scan: ' + errorMessage);
            }
        }
        
        async function startScanWithRestart(scanType, target, options, restart) {
            try {
                const response = await fetch('/api/scans', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({type: scanType, target: target, options: options, restart: restart})
                });
                
                if (!response.ok) {
                    let errorMessage = 'Unknown error';
                    try {
                        const error = await response.json();
                        errorMessage = error.error || error.message || 'Unknown error';
                    } catch (e) {
                        errorMessage = `HTTP ${response.status}: ${response.statusText}`;
                    }
                    alert('Failed to start scan: ' + errorMessage);
                    return;
                }
                
                const data = await response.json();
                
                // Should not get existing_scan response again if restart=true
                if (data.existing_scan && restart) {
                    alert('Error: Existing scan still found. Please try again.');
                    return;
                }
                
                currentScanId = data.scan_id;
                showPage('scans');
                watchScan(currentScanId);
                loadScans();
            } catch (error) {
                console.error('Scan start error:', error);
                let errorMessage = error.message || 'Unknown error';
                if (error.message === 'Failed to fetch') {
                    errorMessage = 'Failed to connect to server. Please make sure the BugHunter Arsenal server is running on http://127.0.0.1:5000';
                }
                alert('Error starting scan: ' + errorMessage);
            }
        }
        
        async function startRescanScan(scanType, target, options) {
            try {
                // Call the rescan endpoint with new options
                const encodedDomain = encodeURIComponent(rescanTargetDomain || target);
                const response = await fetch(`/api/targets/${encodedDomain}/rescan`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({options: options})
                });
                
                if (!response.ok) {
                    let errorMessage = 'Unknown error';
                    try {
                        const error = await response.json();
                        errorMessage = error.error || error.message || 'Unknown error';
                    } catch (e) {
                        errorMessage = `HTTP ${response.status}: ${response.statusText}`;
                    }
                    alert('Failed to start rescan: ' + errorMessage);
                    return;
                }
                
                const data = await response.json();
                currentScanId = data.scan_id;
                
                // Reset rescan mode
                rescanMode = false;
                rescanTargetDomain = null;
                
                showPage('scans');
                watchScan(currentScanId);
                loadScans();
                loadRunningScansDashboard();
            } catch (error) {
                console.error('Rescan start error:', error);
                let errorMessage = error.message || 'Unknown error';
                if (error.message === 'Failed to fetch') {
                    errorMessage = 'Failed to connect to server. Please make sure the BugHunter Arsenal server is running on http://127.0.0.1:5000';
                }
                alert('Error starting rescan: ' + errorMessage);
            }
        }
        
        function watchScan(scanId) {
            // Only watch if this is still the current scan
            if (currentScanId !== scanId) {
                return;
            }
            
            const consoleContent = document.getElementById('scanConsole');
            let isFirstOutput = true;
            
            eventSource = new EventSource(`/api/scans/${scanId}/output`);
            
            eventSource.onmessage = function(event) {
                // Only process if this is still the current scan
                if (currentScanId !== scanId) {
                    if (eventSource) {
                        eventSource.close();
                        eventSource = null;
                    }
                    return;
                }
                
                try {
                    const data = JSON.parse(event.data);
                    
                    // Handle errors from server
                    if (data.error) {
                        consoleContent.textContent = `Error: ${data.error}`;
                        if (eventSource) {
                            eventSource.close();
                            eventSource = null;
                        }
                        return;
                    }
                    
                    // Handle output (including empty strings to confirm connection)
                    if (data.output !== undefined) {
                        // Replace content on first output, append after that
                        if (isFirstOutput || consoleContent.textContent === 'Loading scan output...' || consoleContent.textContent === 'Loading scan output...\n') {
                            consoleContent.textContent = data.output || '';
                            isFirstOutput = false;
                        } else {
                            consoleContent.textContent += data.output || '';
                        }
                        consoleContent.scrollTop = consoleContent.scrollHeight;
                    }
                    
                    if (data.completed) {
                        if (eventSource) {
                            eventSource.close();
                            eventSource = null;
                        }
                        if (currentScanId === scanId) {
                            // Use debounced reload to avoid rapid requests
                            debouncedReloadScans();
                            loadDashboard();
                            loadFindings();
                        }
                    }
                } catch (e) {
                    console.error('Error parsing SSE data:', e, event.data);
                }
            };
            
            eventSource.onerror = function(event) {
                if (currentScanId !== scanId) {
                    if (eventSource) {
                        eventSource.close();
                        eventSource = null;
                    }
                    return;
                }
                
                console.error('EventSource error:', eventSource.readyState);
                
                // Only retry if connection was closed unexpectedly
                if (eventSource.readyState === EventSource.CLOSED) {
                    setTimeout(() => {
                        if (currentScanId === scanId) {
                            console.log('Reconnecting to scan output stream...');
                            watchScan(scanId);
                        }
                    }, 3000);
                }
            };
        }
        
        async function loadScans() {
            try {
                // Use shared scan data cache
                const data = await fetchScanData();
                if (!data) return;
                const running = [];
                const history = [];
                
                data.scans.forEach(scan => {
                    if (scan.status === 'running' || scan.status === 'paused') {
                        running.push(scan);
                    } else {
                        history.push(scan);
                    }
                });
                
                let runningHTML = '';
                if (running.length === 0) {
                    runningHTML = '<div class="empty-state">No running scans</div>';
                } else {
                    running.forEach(scan => {
                        // Format scan parameters
                        const params = [];
                        if (scan.options) {
                            if (scan.options.verbose) params.push('Verbose');
                            if (scan.options.no_subs) params.push('No Subs');
                            if (scan.options.cookie) params.push('Cookie');
                            if (scan.options.x_request_for) params.push(`X-Request-For: ${scan.options.x_request_for}`);
                            if (scan.options.output) params.push(`Output: ${scan.options.output}`);
                        }
                        const paramsText = params.length > 0 ? params.join(' ‚Ä¢ ') : 'Default settings';
                        
                        // Get last output line
                        const lastOutput = scan.last_output || '';
                        
                        // Extract phase from output
                        let currentPhase = '';
                        if (lastOutput) {
                            // Try to match Stage: pattern
                            const stageMatch = lastOutput.match(/Stage:\s*([^-‚Ä¢\n]+)/);
                            if (stageMatch) {
                                let stageText = stageMatch[1].trim();
                                
                                // Map stage names to friendly phase names
                                if (stageText.includes('Subdomain Enumeration') || stageText.includes('Starting subdomain') || stageText.includes('subdomain discovery')) {
                                    currentPhase = 'Subdomain Enumeration';
                                } else if (stageText.includes('URL Crawl') || stageText.includes('Collecting URLs') || stageText.includes('waybackurls') || stageText.includes('katana')) {
                                    currentPhase = 'URL Crawl';
                                } else if (stageText.includes('API key') || stageText.includes('API Leaks') || (stageText.includes('Processing') && stageText.includes('URLs')) || stageText.includes('API key scanning')) {
                                    currentPhase = 'API Leaks';
                                } else if (stageText.includes('XSS Testing') || stageText.includes('XSS') || stageText.includes('XSS vulnerabilities')) {
                                    currentPhase = 'XSS Testing';
                                } else if (stageText.includes('Initializing') || stageText.includes('database') || stageText.includes('scan record')) {
                                    currentPhase = 'Initializing';
                                } else if (stageText.includes('completed') || stageText.includes('Finalizing') || stageText.includes('updating status')) {
                                    currentPhase = 'Finalizing';
                                } else {
                                    // Use the stage text as-is if no match
                                    currentPhase = stageText.length > 30 ? stageText.substring(0, 30) + '...' : stageText;
                                }
                            }
                        }
                        const phaseText = currentPhase ? ` ‚Ä¢ Phase: ${currentPhase}` : '';
                        
                        // Process status display
                        const pid = scan.process_pid || 'N/A';
                        const procStatus = scan.process_status || 'unknown';
                        let procStatusColor = 'var(--text-muted)';
                        let procStatusText = procStatus;
                        if (procStatus === 'running') {
                            procStatusColor = 'var(--success)';
                            procStatusText = '‚úì Running';
                        } else if (procStatus === 'dead') {
                            procStatusColor = 'var(--critical)';
                            procStatusText = '‚úó Dead';
                        } else if (procStatus === 'not_tracked') {
                            procStatusColor = 'var(--high)';
                            procStatusText = '‚ö† Not Tracked';
                        } else if (procStatus === 'tracked') {
                            procStatusColor = 'var(--medium)';
                            procStatusText = '‚Üí Tracked';
                        }
                        
                        // Show resume button for paused scans, pause and stop buttons for running scans
                        const isPaused = scan.status === 'paused';
                        const actionButton = isPaused 
                            ? `<button class="btn btn-success btn-stop" onclick="resumeScan('${scan.scan_id}', event)" style="margin-top: 8px;">‚ñ∂Ô∏è Resume</button>`
                            : `<div style="display: flex; gap: 8px; margin-top: 8px;">
                                <button class="btn btn-warning btn-stop" onclick="pauseScan('${scan.scan_id}', event)" style="flex: 1;">‚è∏Ô∏è Pause</button>
                                <button class="btn btn-danger btn-stop" onclick="stopScan('${scan.scan_id}', event)" style="flex: 1;">Stop</button>
                               </div>`;
                        
                        runningHTML += `
                            <div class="scan-item" onclick="selectScan('${scan.scan_id}')">
                                <div class="scan-item-header">
                                    <div class="scan-item-title">${escapeHtml(scan.target)}</div>
                                    <div class="status-badge status-${scan.status}">${scan.status}</div>
                                </div>
                                <div style="font-size: 12px; color: var(--text-secondary); margin-top: 4px;">
                                    ${scan.type} ‚Ä¢ Started: ${new Date(scan.started_at).toLocaleString(undefined, {timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone})}${phaseText}
                                </div>
                                <div style="font-size: 10px; color: var(--text-muted); margin-top: 2px;">
                                    PID: ${pid} ‚Ä¢ Process: <span style="color: ${procStatusColor};">${procStatusText}</span>
                                </div>
                                <div style="font-size: 10px; color: var(--text-muted); margin-top: 2px;">
                                    ${escapeHtml(paramsText)}
                                </div>
                                <div style="font-size: 10px; color: var(--accent-primary); margin-top: 4px; font-family: 'Courier New', monospace; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">
                                    ${escapeHtml(lastOutput || (isPaused ? 'Scan paused - click Resume to continue' : 'Waiting for output...'))}
                                </div>
                                ${actionButton}
                            </div>
                        `;
                    });
                }
                
                let historyHTML = '';
                if (history.length === 0) {
                    historyHTML = '<div class="empty-state">No scan history</div>';
                } else {
                    // Apply pagination to history
                    const state = paginationState.scans;
                    const paginated = getPaginatedData(history, state.currentPage, state.rowsPerPage);
                    
                    paginated.items.forEach(scan => {
                        // Allow rerun for any scan that's not currently running
                        const canRerun = scan.status !== 'running';
                        // Allow resume for scans that are stopped/failed/incomplete (not running and not completed)
                        const canResume = scan.status !== 'running' && scan.status !== 'completed';
                        const isSelected = selectedScans.has(scan.scan_id);
                        historyHTML += `
                            <div class="scan-item" onclick="selectScan('${scan.scan_id}')">
                                <div style="display: flex; align-items: center; gap: 12px; width: 100%;">
                                    <div class="checkbox-cell" onclick="event.stopPropagation();">
                                        <input type="checkbox" class="scan-checkbox" value="${scan.scan_id}" ${isSelected ? 'checked' : ''} onchange="toggleScanSelection('${scan.scan_id}', event)">
                                    </div>
                                    <div style="flex: 1;">
                                        <div class="scan-item-header">
                                            <div class="scan-item-title">${escapeHtml(scan.target)}</div>
                                            <div class="status-badge status-${scan.status}">${scan.status}</div>
                                        </div>
                                        <div style="font-size: 12px; color: var(--text-secondary); margin-top: 4px;">
                                            ${scan.type} ‚Ä¢ Started: ${new Date(scan.started_at).toLocaleString(undefined, {timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone})}
                                            ${scan.completed_at ? ` ‚Ä¢ Completed: ${new Date(scan.completed_at).toLocaleString(undefined, {timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone})}` : ''}
                                        </div>
                                        <div style="display: flex; gap: 8px; margin-top: 8px;">
                                            ${canResume ? `<button class="btn btn-success btn-stop" onclick="resumeScan('${scan.scan_id}', event)" title="Resume from last checkpoint">‚ñ∂Ô∏è Resume</button>` : ''}
                                            ${canRerun ? `<button class="btn btn-primary btn-stop" onclick="rerunScan('${scan.scan_id}', event)" title="Start a new scan with same parameters">üîÑ Rerun</button>` : ''}
                                            <button class="btn btn-danger btn-stop" onclick="deleteScan('${scan.scan_id}', event)">üóëÔ∏è Delete</button>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        `;
                    });
                }
                
                document.getElementById('runningScans').innerHTML = runningHTML;
                document.getElementById('scanHistory').innerHTML = historyHTML;
                
                // Render pagination for scan history
                if (history.length > 0) {
                    const state = paginationState.scans;
                    const paginated = getPaginatedData(history, state.currentPage, state.rowsPerPage);
                    renderPagination('scansPagination', paginated, null, null, 'scans');
                } else {
                    document.getElementById('scansPagination').innerHTML = '';
                }
                
                // Update bulk delete button state
                updateBulkDeleteButton();
                updateSelectAllScansState();
            } catch (error) {
                console.error('Error loading scans:', error);
            }
        }
        
        async function selectScan(scanId) {
            // Always clear console when selecting a scan (prevents stacking)
            const consoleContent = document.getElementById('scanConsole');
            consoleContent.textContent = 'Loading scan output...\n';
            
            // Close existing EventSource before creating new one
            if (eventSource) {
                eventSource.close();
                eventSource = null;
            }
            
            currentScanId = scanId;
            watchScan(scanId);
        }
        
        function toggleScanSelection(scanId, event) {
            if (event) {
                event.stopPropagation();
            }
            const checkbox = event.target;
            if (checkbox.checked) {
                selectedScans.add(scanId);
            } else {
                selectedScans.delete(scanId);
            }
            updateBulkDeleteButton();
            updateSelectAllScansState();
        }
        
        function toggleSelectAllScans() {
            const checked = document.getElementById('selectAllScans')?.checked;
            document.querySelectorAll('.scan-checkbox').forEach(cb => {
                cb.checked = checked;
                if (checked) {
                    selectedScans.add(cb.value);
                } else {
                    selectedScans.delete(cb.value);
                }
            });
            updateBulkDeleteButton();
        }
        
        function updateSelectAllScansState() {
            const checkboxes = document.querySelectorAll('.scan-checkbox');
            const allChecked = checkboxes.length > 0 && Array.from(checkboxes).every(cb => cb.checked);
            if (document.getElementById('selectAllScans')) {
                document.getElementById('selectAllScans').checked = allChecked;
            }
        }
        
        function updateBulkDeleteButton() {
            const bulkDeleteBtn = document.getElementById('bulkDeleteScansBtn');
            if (bulkDeleteBtn) {
                if (selectedScans.size > 0) {
                    bulkDeleteBtn.style.display = 'inline-block';
                    bulkDeleteBtn.textContent = `Delete Selected (${selectedScans.size})`;
                } else {
                    bulkDeleteBtn.style.display = 'none';
                }
            }
        }
        
        async function deleteScan(scanId, event) {
            if (event) {
                event.stopPropagation();
            }
            
            if (!confirm('Are you sure you want to delete this scan?\n\nThis will permanently delete:\n‚Ä¢ The scan record\n‚Ä¢ All scan output\n\nThis action cannot be undone.')) {
                return;
            }
            
            try {
                const response = await fetch(`/api/scans/${scanId}`, {
                    method: 'DELETE'
                });
                
                if (!response.ok) {
                    const error = await response.json();
                    alert('Failed to delete scan: ' + (error.error || 'Unknown error'));
                    return;
                }
                
                selectedScans.delete(scanId);
                loadScans();
                if (currentScanId === scanId) {
                    currentScanId = null;
                    if (eventSource) {
                        eventSource.close();
                        eventSource = null;
                    }
                    document.getElementById('scanConsole').textContent = 'Scan deleted.';
                }
            } catch (error) {
                alert('Error deleting scan: ' + error.message);
            }
        }
        
        async function bulkDeleteScans() {
            if (selectedScans.size === 0) {
                alert('Please select at least one scan to delete');
                return;
            }
            
            if (!confirm(`Are you sure you want to delete ${selectedScans.size} scan(s)?\n\nThis will permanently delete:\n‚Ä¢ All selected scan records\n‚Ä¢ All scan output for selected scans\n\nThis action cannot be undone.`)) {
                return;
            }
            
            try {
                const response = await fetch('/api/scans/bulk', {
                    method: 'DELETE',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        scan_ids: Array.from(selectedScans)
                    })
                });
                
                if (!response.ok) {
                    const error = await response.json();
                    alert('Failed to delete scans: ' + (error.error || 'Unknown error'));
                    return;
                }
                
                const data = await response.json();
                alert(`Successfully deleted ${data.deleted} scan(s).`);
                
                // Check if current scan was deleted before clearing selection
                const wasCurrentScanDeleted = currentScanId && selectedScans.has(currentScanId);
                
                // Clear selection and reload
                selectedScans.clear();
                loadScans();
                updateBulkDeleteButton();
                
                // Clear console if current scan was deleted
                if (wasCurrentScanDeleted) {
                    currentScanId = null;
                    if (eventSource) {
                        eventSource.close();
                        eventSource = null;
                    }
                    document.getElementById('scanConsole').textContent = 'Selected scans deleted.';
                }
            } catch (error) {
                alert('Error deleting scans: ' + error.message);
            }
        }
        
        async function rerunScan(scanId, event) {
            if (event) {
                event.stopPropagation();
            }
            
            const confirmMessage = `Are you sure you want to rerun this scan?\n\n` +
                `This will start a new scan with the same target and options as the original.\n` +
                `The new scan will appear in the running scans section.\n\n` +
                `Continue?`;
            
            if (!confirm(confirmMessage)) {
                return;
            }
            
            try {
                const response = await fetch(`/api/scans/${scanId}/rerun`, {
                    method: 'POST'
                });
                
                if (!response.ok) {
                    const error = await response.json();
                    alert('Failed to rerun scan: ' + (error.error || 'Unknown error'));
                    return;
                }
                
                const data = await response.json();
                currentScanId = data.scan_id;
                
                showPage('scans');
                watchScan(currentScanId);
                debouncedReloadScans();
            } catch (error) {
                alert('Error rerunning scan: ' + error.message);
            }
        }
        
        async function resumeScan(scanId, event) {
            if (event) {
                event.stopPropagation();
            }
            
            const confirmMessage = `Are you sure you want to resume this scan?\n\n` +
                `This will resume the scan from its last checkpoint.\n` +
                `The scan will continue from where it was stopped.\n\n` +
                `Continue?`;
            
            if (!confirm(confirmMessage)) {
                return;
            }
            
            try {
                const response = await fetch(`/api/scans/${scanId}/resume`, {
                    method: 'POST'
                });
                
                if (!response.ok) {
                    const error = await response.json();
                    alert('Failed to resume scan: ' + (error.error || 'Unknown error'));
                    return;
                }
                
                const data = await response.json();
                currentScanId = data.scan_id;
                
                showPage('scans');
                watchScan(currentScanId);
                loadScans();
                loadRunningScansDashboard();
                
                if (data.resumed && data.checkpoint) {
                    // Show a brief notification that scan was resumed from checkpoint
                    console.log(`Scan resumed from checkpoint: ${data.checkpoint}`);
                }
            } catch (error) {
                alert('Error resuming scan: ' + error.message);
            }
        }
        
        async function pauseScan(scanId, event) {
            if (event) {
                event.stopPropagation();
            }
            if (!confirm('Are you sure you want to pause this scan? You can resume it later from where it stopped.')) return;
            
            try {
                const response = await fetch(`/api/scans/${scanId}/pause`, {method: 'POST'});
                if (response.ok) {
                    loadScans();
                    loadRunningScansDashboard();
                    if (currentScanId === scanId) {
                        if (eventSource) {
                            eventSource.close();
                            eventSource = null;
                        }
                        document.getElementById('scanConsole').textContent += '\n\n[Scan paused by user]';
                    }
                    if (modalScanId === scanId) {
                        const consoleElement = document.getElementById('scanOutputModalConsole');
                        if (consoleElement) {
                            consoleElement.textContent += '\n\n[Scan paused by user]';
                        }
                    }
                } else {
                    const error = await response.json();
                    alert('Failed to pause scan: ' + (error.error || 'Unknown error'));
                }
            } catch (error) {
                console.error('Error pausing scan:', error);
                alert('Error pausing scan: ' + error.message);
            }
        }
        
        async function stopScan(scanId, event) {
            if (event) {
                event.stopPropagation();
            }
            if (!confirm('Are you sure you want to stop this scan? This action cannot be undone.')) return;
            
            try {
                const response = await fetch(`/api/scans/${scanId}/stop`, {method: 'POST'});
                if (response.ok) {
                    loadScans();
                    loadRunningScansDashboard();
                    if (currentScanId === scanId) {
                        currentScanId = null;
                        if (eventSource) {
                            eventSource.close();
                            eventSource = null;
                        }
                        document.getElementById('scanConsole').textContent = 'Scan stopped.';
                    }
                    if (modalScanId === scanId) {
                        const consoleElement = document.getElementById('scanOutputModalConsole');
                        if (consoleElement) {
                            consoleElement.textContent += '\n\n[Scan stopped by user]';
                        }
                    }
                }
            } catch (error) {
                alert('Error stopping scan: ' + error.message);
            }
        }
        
        function formatDuration(startTime) {
            const now = new Date();
            // Parse ISO timestamp string, handling both with and without timezone
            const start = new Date(startTime);
            const diff = Math.floor((now - start) / 1000); // seconds
            
            if (diff < 60) {
                return `${diff}s`;
            } else if (diff < 3600) {
                const minutes = Math.floor(diff / 60);
                const seconds = diff % 60;
                return `${minutes}m ${seconds}s`;
            } else {
                const hours = Math.floor(diff / 3600);
                const minutes = Math.floor((diff % 3600) / 60);
                return `${hours}h ${minutes}m`;
            }
        }
        
        async function loadRunningScansDashboard() {
            try {
                // Use shared scan data cache - same data as loadScans
                const data = await fetchScanData();
                if (!data) return;
                const running = data.scans.filter(scan => scan.status === 'running' || scan.status === 'paused');
                
                const container = document.getElementById('runningScansDashboard');
                const card = document.getElementById('runningScansCard');
                
                if (running.length === 0) {
                    if (card) card.style.display = 'none';
                    return;
                }
                
                // Show the card if there are running scans
                if (card) card.style.display = 'block';
                
                // Get existing scan IDs to preserve DOM elements
                const existingItems = container.querySelectorAll('.running-scan-item');
                const existingScanIds = new Set();
                existingItems.forEach(item => {
                    const scanId = item.getAttribute('data-scan-id');
                    if (scanId) {
                        existingScanIds.add(scanId);
                    }
                });
                
                // Update existing items or create new ones
                const currentScanIds = new Set();
                running.forEach(scan => {
                    currentScanIds.add(scan.scan_id);
                    const duration = formatDuration(scan.started_at);
                    const startedTime = new Date(scan.started_at).toLocaleString(undefined, {timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone});
                    
                    let item = container.querySelector(`[data-scan-id="${scan.scan_id}"]`);
                    
                    // Format scan parameters
                    const params = [];
                    if (scan.options) {
                        if (scan.options.verbose) params.push('Verbose');
                        if (scan.options.no_subs) params.push('No Subs');
                        if (scan.options.cookie) params.push('Cookie');
                        if (scan.options.x_request_for) params.push(`X-Request-For: ${scan.options.x_request_for}`);
                        if (scan.options.output) params.push(`Output: ${scan.options.output}`);
                    }
                    const paramsText = params.length > 0 ? params.join(' ‚Ä¢ ') : 'Default settings';
                    
                    // Get last output line
                    const lastOutput = scan.last_output || '';
                    
                    // Extract phase from output
                    let currentPhase = '';
                    if (lastOutput) {
                        // Try to match Stage: pattern
                        const stageMatch = lastOutput.match(/Stage:\s*([^-‚Ä¢\n]+)/);
                        if (stageMatch) {
                            let stageText = stageMatch[1].trim();
                            
                            // Map stage names to friendly phase names
                            if (stageText.includes('Subdomain Enumeration') || stageText.includes('Starting subdomain') || stageText.includes('subdomain discovery')) {
                                currentPhase = 'Subdomain Enumeration';
                            } else if (stageText.includes('URL Crawl') || stageText.includes('Collecting URLs') || stageText.includes('waybackurls') || stageText.includes('katana')) {
                                currentPhase = 'URL Crawl';
                            } else if (stageText.includes('API key') || stageText.includes('API Leaks') || (stageText.includes('Processing') && stageText.includes('URLs')) || stageText.includes('API key scanning')) {
                                currentPhase = 'API Leaks';
                            } else if (stageText.includes('XSS Testing') || stageText.includes('XSS') || stageText.includes('XSS vulnerabilities')) {
                                currentPhase = 'XSS Testing';
                            } else if (stageText.includes('Initializing') || stageText.includes('database') || stageText.includes('scan record')) {
                                currentPhase = 'Initializing';
                            } else if (stageText.includes('completed') || stageText.includes('Finalizing') || stageText.includes('updating status')) {
                                currentPhase = 'Finalizing';
                            } else {
                                // Use the stage text as-is if no match
                                currentPhase = stageText.length > 30 ? stageText.substring(0, 30) + '...' : stageText;
                            }
                        }
                    }
                    
                    if (item) {
                        // Update existing item
                        const isPaused = scan.status === 'paused';
                        const detailsElement = item.querySelector('.running-scan-details');
                        if (detailsElement) {
                            const phaseText = currentPhase ? ` ‚Ä¢ Phase: ${currentPhase}` : '';
                            const statusText = isPaused ? 'Paused' : `Running for ${duration}`;
                            detailsElement.textContent = `${scan.type} ‚Ä¢ ${statusText} ‚Ä¢ Started: ${startedTime}${phaseText}`;
                        }
                        
                        // Update spinner/indicator
                        const spinnerElement = item.querySelector('.spinner, .pause-indicator');
                        const titleElement = item.querySelector('.running-scan-title');
                        if (spinnerElement && titleElement) {
                            if (isPaused) {
                                // Replace spinner with pause icon
                                if (spinnerElement.classList.contains('spinner')) {
                                    spinnerElement.className = 'pause-indicator';
                                    spinnerElement.textContent = '‚è∏';
                                    spinnerElement.style.cssText = 'color: #ffc107; font-size: 16px; margin-right: 8px; display: inline-block;';
                                }
                            } else {
                                // Ensure spinner is shown for running scans
                                if (spinnerElement.classList.contains('pause-indicator')) {
                                    spinnerElement.className = 'spinner';
                                    spinnerElement.textContent = '';
                                    spinnerElement.style.cssText = '';
                                }
                            }
                        }
                        
                        // Update button(s)
                        const buttonContainer = item.querySelector('div[style*="display: flex"]');
                        const buttonElement = item.querySelector('button');
                        
                        if (isPaused) {
                            // Paused: show single resume button
                            if (buttonContainer) {
                                buttonContainer.outerHTML = '<button class="btn btn-success btn-stop" onclick="resumeScan(\'' + scan.scan_id + '\', event); event.stopPropagation();">‚ñ∂Ô∏è Resume</button>';
                            } else if (buttonElement) {
                                buttonElement.className = 'btn btn-success btn-stop';
                                buttonElement.textContent = '‚ñ∂Ô∏è Resume';
                                buttonElement.onclick = (e) => {
                                    e.stopPropagation();
                                    resumeScan(scan.scan_id, e);
                                };
                            }
                        } else {
                            // Running: show pause and stop buttons
                            if (buttonElement && !buttonContainer) {
                                // Replace single button with two buttons
                                buttonElement.outerHTML = `<div style="display: flex; gap: 8px;">
                                    <button class="btn btn-warning btn-stop" onclick="pauseScan('${scan.scan_id}', event); event.stopPropagation();" style="flex: 1;">‚è∏Ô∏è Pause</button>
                                    <button class="btn btn-danger btn-stop" onclick="stopScan('${scan.scan_id}', event); event.stopPropagation();" style="flex: 1;">Stop</button>
                                </div>`;
                            } else if (buttonContainer) {
                                // Update existing buttons
                                const pauseBtn = buttonContainer.querySelector('.btn-warning');
                                const stopBtn = buttonContainer.querySelector('.btn-danger');
                                if (pauseBtn) {
                                    pauseBtn.onclick = (e) => {
                                        e.stopPropagation();
                                        pauseScan(scan.scan_id, e);
                                    };
                                }
                                if (stopBtn) {
                                    stopBtn.onclick = (e) => {
                                        e.stopPropagation();
                                        stopScan(scan.scan_id, e);
                                    };
                                }
                            }
                        }
                        
                        // Update PID and process status
                        const pidParamsElement = item.querySelectorAll('.running-scan-params')[0];
                        if (pidParamsElement) {
                            const pid = scan.process_pid || 'N/A';
                            const procStatus = scan.process_status || 'unknown';
                            let procStatusColor = 'var(--text-muted)';
                            let procStatusText = procStatus;
                            if (procStatus === 'running') {
                                procStatusColor = 'var(--success)';
                                procStatusText = '‚úì Running';
                            } else if (procStatus === 'dead') {
                                procStatusColor = 'var(--critical)';
                                procStatusText = '‚úó Dead';
                            } else if (procStatus === 'not_tracked') {
                                procStatusColor = 'var(--high)';
                                procStatusText = '‚ö† Not Tracked';
                            } else if (procStatus === 'tracked') {
                                procStatusColor = 'var(--medium)';
                                procStatusText = '‚Üí Tracked';
                            }
                            pidParamsElement.innerHTML = `PID: ${pid} ‚Ä¢ Process: <span style="color: ${procStatusColor};">${procStatusText}</span>`;
                        }
                        
                        const paramsElement = item.querySelectorAll('.running-scan-params')[1];
                        if (paramsElement) {
                            paramsElement.textContent = paramsText;
                        }
                        
                        const outputElement = item.querySelector('.running-scan-output');
                        if (outputElement) {
                            outputElement.textContent = lastOutput || (isPaused ? 'Scan paused - click Resume to continue' : 'Waiting for output...');
                        }
                    } else {
                        // Create new item
                        const targetEscaped = scan.target.replace(/\\/g, '\\\\').replace(/'/g, "\\'").replace(/\n/g, '\\n').replace(/\r/g, '\\r');
                        const newItem = document.createElement('div');
                        newItem.className = 'running-scan-item';
                        newItem.setAttribute('data-scan-id', scan.scan_id);
                        newItem.onclick = (e) => showScanOutputModal(scan.scan_id, scan.target, e);
                        // Extract phase from output
                        let currentPhase = '';
                        if (lastOutput) {
                            // Try to match Stage: pattern
                            const stageMatch = lastOutput.match(/Stage:\s*([^-‚Ä¢\n]+)/);
                            if (stageMatch) {
                                let stageText = stageMatch[1].trim();
                                
                                // Map stage names to friendly phase names
                                if (stageText.includes('Subdomain Enumeration') || stageText.includes('Starting subdomain') || stageText.includes('subdomain discovery')) {
                                    currentPhase = 'Subdomain Enumeration';
                                } else if (stageText.includes('URL Crawl') || stageText.includes('Collecting URLs') || stageText.includes('waybackurls') || stageText.includes('katana')) {
                                    currentPhase = 'URL Crawl';
                                } else if (stageText.includes('API key') || stageText.includes('API Leaks') || (stageText.includes('Processing') && stageText.includes('URLs')) || stageText.includes('API key scanning')) {
                                    currentPhase = 'API Leaks';
                                } else if (stageText.includes('XSS Testing') || stageText.includes('XSS') || stageText.includes('XSS vulnerabilities')) {
                                    currentPhase = 'XSS Testing';
                                } else if (stageText.includes('Initializing') || stageText.includes('database') || stageText.includes('scan record')) {
                                    currentPhase = 'Initializing';
                                } else if (stageText.includes('completed') || stageText.includes('Finalizing') || stageText.includes('updating status')) {
                                    currentPhase = 'Finalizing';
                                } else {
                                    // Use the stage text as-is if no match
                                    currentPhase = stageText.length > 30 ? stageText.substring(0, 30) + '...' : stageText;
                                }
                            }
                        }
                        const phaseText = currentPhase ? ` ‚Ä¢ Phase: ${currentPhase}` : '';
                        
                        // Check if scan is paused
                        const isPaused = scan.status === 'paused';
                        const statusText = isPaused ? 'Paused' : `Running for ${duration}`;
                        
                        // Process status display
                        const pid = scan.process_pid || 'N/A';
                        const procStatus = scan.process_status || 'unknown';
                        let procStatusColor = 'var(--text-muted)';
                        let procStatusText = procStatus;
                        if (procStatus === 'running') {
                            procStatusColor = 'var(--success)';
                            procStatusText = '‚úì Running';
                        } else if (procStatus === 'dead') {
                            procStatusColor = 'var(--critical)';
                            procStatusText = '‚úó Dead';
                        } else if (procStatus === 'not_tracked') {
                            procStatusColor = 'var(--high)';
                            procStatusText = '‚ö† Not Tracked';
                        } else if (procStatus === 'tracked') {
                            procStatusColor = 'var(--medium)';
                            procStatusText = '‚Üí Tracked';
                        }
                        
                        // Choose indicator: pause icon for paused, spinner for running
                        const indicator = isPaused 
                            ? '<span class="pause-indicator" style="color: #ffc107; font-size: 16px; margin-right: 8px; display: inline-block;">‚è∏</span>'
                            : '<span class="spinner"></span>';
                        
                        // Choose button: resume for paused, pause and stop for running
                        const actionButton = isPaused
                            ? `<button class="btn btn-success btn-stop" onclick="resumeScan('${scan.scan_id}', event); event.stopPropagation();">‚ñ∂Ô∏è Resume</button>`
                            : `<div style="display: flex; gap: 8px;">
                                <button class="btn btn-warning btn-stop" onclick="pauseScan('${scan.scan_id}', event); event.stopPropagation();" style="flex: 1;">‚è∏Ô∏è Pause</button>
                                <button class="btn btn-danger btn-stop" onclick="stopScan('${scan.scan_id}', event); event.stopPropagation();" style="flex: 1;">Stop</button>
                               </div>`;
                        
                        newItem.innerHTML = `
                            <div class="running-scan-info">
                                <div class="running-scan-title">
                                    ${indicator}
                                    <span>${escapeHtml(scan.target)}</span>
                                </div>
                                <div class="running-scan-details">
                                    ${scan.type} ‚Ä¢ ${statusText} ‚Ä¢ Started: ${startedTime}${phaseText}
                                </div>
                                <div class="running-scan-params" style="font-size: 10px; color: var(--text-muted);">
                                    PID: ${pid} ‚Ä¢ Process: <span style="color: ${procStatusColor};">${procStatusText}</span>
                                </div>
                                <div class="running-scan-params">
                                    ${escapeHtml(paramsText)}
                                </div>
                                <div class="running-scan-output">
                                    ${escapeHtml(lastOutput || (isPaused ? 'Scan paused - click Resume to continue' : 'Waiting for output...'))}
                                </div>
                            </div>
                            ${actionButton}
                        `;
                        container.appendChild(newItem);
                    }
                });
                
                // Remove items that are no longer running
                existingItems.forEach(item => {
                    const scanId = item.getAttribute('data-scan-id');
                    if (scanId && !currentScanIds.has(scanId)) {
                        item.remove();
                    }
                });
                
                // If no items left, show empty state
                if (container.children.length === 0) {
                    container.innerHTML = '<div class="empty-state">No scans currently running</div>';
                }
            } catch (error) {
                console.error('Error loading running scans:', error);
            }
        }
        
        async function loadDashboard() {
            try {
                const response = await fetch('/api/results');
                if (!response.ok) return;
                
                const data = await response.json();
                
                // Don't update stats cards here - they're managed by the stats stream
                // Stats cards are updated by updateStatsCards() from the /api/stats/stream
                
                const recentFindingsCard = document.getElementById('recentFindingsCard');
                let recentHTML = '';
                
                // Check if there are any findings to display
                // Get current stats from the stats cards (managed by stats stream)
                const statsGrid = document.getElementById('statsGrid');
                let totalKeys = 0;
                if (statsGrid) {
                    const statValues = statsGrid.querySelectorAll('.stat-value');
                    if (statValues.length >= 3) {
                        totalKeys = parseInt(statValues[2].textContent.trim()) || 0;
                    }
                }
                // Fallback to results stats if stats stream hasn't populated yet
                if (totalKeys === 0) {
                    totalKeys = data.stats.total_keys || 0;
                }
                const hasFindings = totalKeys > 0;
                
                if (!hasFindings || data.domains.length === 0) {
                    recentHTML = '<div class="empty-state">No findings yet. Start a scan to find API keys.</div>';
                    const paginationContainer = document.getElementById('recentFindingsPagination');
                    if (paginationContainer) paginationContainer.innerHTML = '';
                } else {
                    // Flatten findings for pagination
                    const allRecentFindings = [];
                    data.domains.forEach(domain => {
                        Object.keys(domain.api_keys_found || {}).forEach(url => {
                            Object.keys(domain.api_keys_found[url] || {}).forEach(provider => {
                                const keys = domain.api_keys_found[url][provider].keys || [];
                                keys.forEach(key => {
                                    allRecentFindings.push({...key, url, domain: domain.domain, provider});
                                });
                            });
                        });
                    });
                    
                    // Sort by most recent (found_at timestamp, descending)
                    allRecentFindings.sort((a, b) => {
                        const dateA = a.found_at ? new Date(a.found_at).getTime() : (a.key_id || 0);
                        const dateB = b.found_at ? new Date(b.found_at).getTime() : (b.key_id || 0);
                        return dateB - dateA; // Most recent first
                    });
                    
                    // Apply pagination
                    const state = paginationState.recentFindings;
                    const paginated = getPaginatedData(allRecentFindings, state.currentPage, state.rowsPerPage);
                    
                    recentHTML = '<div style="font-size: 12px; color: var(--text-secondary); margin-bottom: 12px;">Showing recent findings from all domains</div>';
                    paginated.items.forEach(finding => {
                        recentHTML += `
                            <div style="padding: 12px; border-bottom: 1px solid var(--border-color);">
                                <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px;">
                                    <div>
                                        <span class="severity-badge severity-${finding.severity || 'medium'}">${finding.severity || 'medium'}</span>
                                        <span style="margin-left: 8px; color: var(--text-secondary);">${escapeHtml(finding.provider)}</span>
                                    </div>
                                    <div>
                                        <button class="action-btn" onclick="editFinding(${finding.key_id})">Edit</button>
                                    </div>
                                </div>
                                <div style="font-size: 11px; color: var(--text-secondary); font-family: monospace; word-break: break-all;">
                                    ${escapeHtml(finding.key_value.substring(0, 80))}${finding.key_value.length > 80 ? '...' : ''}
                                </div>
                                <div style="font-size: 11px; color: var(--text-muted); margin-top: 4px;">
                                    ${escapeHtml(finding.url)}
                                </div>
                            </div>
                        `;
                    });
                    
                    // Render pagination for recent findings
                    const paginationContainer = document.getElementById('recentFindingsPagination');
                    if (paginationContainer) {
                        renderPagination('recentFindingsPagination', paginated, null, null, 'recentFindings');
                    }
                }
                
                // Show/hide the card based on whether there are findings
                if (hasFindings) {
                    recentFindingsCard.style.display = 'block';
                } else {
                    recentFindingsCard.style.display = 'none';
                }
                
                document.getElementById('recentFindings').innerHTML = recentHTML || '<div class="empty-state">No recent findings</div>';
            } catch (error) {
                console.error('Error loading dashboard:', error);
            }
        }
        
        async function deleteDomain(domain, event) {
            event.stopPropagation();
            
            if (!confirm(`‚ö†Ô∏è WARNING: This will permanently delete domain "${domain}" and ALL associated data:\n\n‚Ä¢ All scan results for this domain\n‚Ä¢ All URLs found for this domain\n‚Ä¢ All API keys found for this domain\n\nThis action cannot be undone!\n\nAre you sure you want to proceed?`)) {
                return;
            }
            
            if (!confirm(`Last chance! Are you absolutely sure you want to delete "${domain}" and purge all its findings?`)) {
                return;
            }
            
            try {
                const encodedDomain = encodeURIComponent(domain);
                const response = await fetch(`/api/scans/by-domain/${encodedDomain}`, {
                    method: 'DELETE'
                });
                
                if (!response.ok) {
                    const error = await response.json();
                    alert('Failed to delete domain: ' + (error.error || 'Unknown error'));
                    return;
                }
                
                const data = await response.json();
                alert(`Domain "${domain}" deleted successfully.\n\nDeleted:\n‚Ä¢ ${data.scans_deleted} scan(s)\n‚Ä¢ ${data.urls_deleted} URL(s)\n‚Ä¢ ${data.keys_deleted} API key(s)`);
                
                loadDashboard();
                loadFindings();
            } catch (error) {
                alert('Error deleting domain: ' + error.message);
            }
        }
        
        async function loadFindings() {
            try {
                const severity = document.getElementById('filterSeverity')?.value || '';
                const falsePositive = document.getElementById('filterFalsePositive')?.value || '';
                const verified = document.getElementById('filterVerified')?.value || '';
                const provider = document.getElementById('filterProvider')?.value || '';
                const domain = document.getElementById('filterDomain')?.value || '';
                
                // Reset pagination to page 1 when filters change (compare current filters with stored)
                const currentFilters = `${severity}-${falsePositive}-${verified}-${provider}-${domain}`;
                if (!window.lastFindingsFilters) {
                    window.lastFindingsFilters = currentFilters;
                } else if (window.lastFindingsFilters !== currentFilters) {
                    paginationState.findings.currentPage = 1;
                    window.lastFindingsFilters = currentFilters;
                }
                
                let url = '/api/findings?limit=5000';
                if (severity) url += `&severity=${severity}`;
                if (falsePositive !== '') url += `&false_positive=${falsePositive}`;
                if (verified !== '') url += `&verified=${verified}`;
                if (provider) url += `&provider=${provider}`;
                if (domain) url += `&domain=${domain}`;
                
                const response = await fetch(url);
                if (!response.ok) return;
                
                const data = await response.json();
                allFindings = data.findings || [];
                
                if (allFindings.length === 0) {
                    document.getElementById('findingsTableContainer').innerHTML = '<div class="empty-state">No findings found</div>';
                    const paginationContainer = document.getElementById('findingsPagination');
                    if (paginationContainer) paginationContainer.innerHTML = '';
                    selectedFindings.clear();
                    return;
                }
                
                // Group findings by key_value and provider (to keep different providers separate)
                const groupedFindings = {};
                allFindings.forEach(finding => {
                    const groupKey = `${finding.key_value}|${finding.provider}`;
                    if (!groupedFindings[groupKey]) {
                        groupedFindings[groupKey] = [];
                    }
                    groupedFindings[groupKey].push(finding);
                });
                
                // Convert grouped findings to array for pagination
                const groupedFindingsArray = Object.keys(groupedFindings).map(groupKey => {
                    const occurrences = groupedFindings[groupKey];
                    const firstFinding = occurrences[0];
                    return {
                        ...firstFinding,
                        occurrences: occurrences,
                        occurrencesCount: occurrences.length
                    };
                });
                
                // Apply pagination
                const state = paginationState.findings;
                // Ensure currentPage is valid
                const totalPages = Math.ceil(groupedFindingsArray.length / state.rowsPerPage);
                if (state.currentPage > totalPages && totalPages > 0) {
                    state.currentPage = totalPages;
                }
                const paginated = getPaginatedData(groupedFindingsArray, state.currentPage, state.rowsPerPage);
                
                let html = '<table class="findings-table"><thead><tr>';
                html += '<th class="checkbox-cell"><input type="checkbox" id="selectAllCheckbox" onchange="toggleSelectAll()"></th>';
                html += '<th>Severity</th><th>Status</th><th>Provider</th><th>Key Value</th><th>Occurrences</th><th>Domain</th><th>Found</th><th>Actions</th>';
                html += '</tr></thead><tbody>';
                
                paginated.items.forEach(groupedFinding => {
                    const isVerified = groupedFinding.verified === 1 || groupedFinding.verified === true;
                    const verifiedClass = isVerified ? 'finding-verified' : '';
                    const verifiedBadge = isVerified ? '<span class="verified-badge">‚úì Verified</span>' : '';
                    const fpBadge = groupedFinding.false_positive === 1 || groupedFinding.false_positive === true ? '<span class="false-positive-badge badge-fp">FP</span>' : '';
                    const statusBadges = (verifiedBadge + ' ' + fpBadge).trim() || '<span style="color: var(--text-muted); font-size: 11px;">Unverified</span>';
                    
                    // Get unique URLs from occurrences
                    const uniqueUrls = [...new Set(groupedFinding.occurrences.map(f => f.url).filter(Boolean))];
                    const uniqueUrlsCount = uniqueUrls.length;
                    
                    // Prepare occurrences data for modal
                    const modalId = `key-occurrences-${groupedFinding.key_id}`;
                    const occurrencesData = JSON.stringify(groupedFinding.occurrences.map(f => ({
                        url: f.url,
                        key_id: f.key_id,
                        severity: f.severity,
                        verified: f.verified,
                        false_positive: f.false_positive,
                        validation_status: f.validation_status || 'manual',
                        notes: f.notes || '',
                        key_value: f.key_value,
                        domain: f.domain,
                        found_at: f.found_at
                    }))).replace(/"/g, '&quot;');
                    
                    // Show occurrences count with clickable link - always show it as clickable to view all URLs
                    const occurrencesDisplay = groupedFinding.occurrencesCount > 1 
                        ? `<span style="font-size: 11px; color: var(--accent-primary); cursor: pointer; text-decoration: underline;" onclick="showKeyOccurrencesModal('${modalId}', ${occurrencesData})" title="Click to view all ${groupedFinding.occurrencesCount} occurrences across ${uniqueUrlsCount} URL${uniqueUrlsCount !== 1 ? 's' : ''}">${groupedFinding.occurrencesCount} occurrence${groupedFinding.occurrencesCount !== 1 ? 's' : ''} (${uniqueUrlsCount} URL${uniqueUrlsCount !== 1 ? 's' : ''})</span>`
                        : `<span style="font-size: 11px; color: var(--accent-primary); cursor: pointer; text-decoration: underline;" onclick="showKeyOccurrencesModal('${modalId}', ${occurrencesData})" title="Click to view occurrence">1 occurrence</span>`;
                    
                    // Checkbox should select all occurrences
                    const allKeyIds = groupedFinding.occurrences.map(f => f.key_id).join(',');
                    
                    html += `
                        <tr class="${verifiedClass}">
                            <td class="checkbox-cell">
                                <input type="checkbox" class="finding-checkbox" value="${groupedFinding.key_id}" data-key-ids="${allKeyIds}" onchange="toggleFindingGroup(this)">
                            </td>
                            <td><span class="severity-badge severity-${groupedFinding.severity || 'medium'}">${groupedFinding.severity || 'medium'}</span></td>
                            <td>${statusBadges}</td>
                            <td>${escapeHtml(groupedFinding.provider)}</td>
                            <td><span class="key-value" title="${escapeHtml(groupedFinding.key_value)}">${escapeHtml(groupedFinding.key_value.substring(0, 40))}${groupedFinding.key_value.length > 40 ? '...' : ''}</span></td>
                            <td>${occurrencesDisplay}</td>
                            <td>${escapeHtml(groupedFinding.domain)}</td>
                            <td style="font-size: 11px; color: var(--text-secondary);">${new Date(groupedFinding.found_at).toLocaleString(undefined, {timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone})}</td>
                            <td>
                                <button class="action-btn action-btn-small" onclick="editFinding(${groupedFinding.key_id})">Edit</button>
                                <button class="action-btn btn-danger action-btn-small" onclick="deleteFindingGroup(${allKeyIds})">Delete</button>
                            </td>
                        </tr>
                    `;
                });
                
                html += '</tbody></table>';
                document.getElementById('findingsTableContainer').innerHTML = html;
                
                // Render pagination
                renderPagination('findingsPagination', paginated, null, null, 'findings');
            } catch (error) {
                console.error('Error loading findings:', error);
            }
        }
        
        function toggleSelectAll() {
            const checked = document.getElementById('selectAllFindings')?.checked || document.getElementById('selectAllCheckbox')?.checked;
            document.querySelectorAll('.finding-checkbox').forEach(cb => {
                cb.checked = checked;
                // Handle grouped findings
                const keyIdsStr = cb.getAttribute('data-key-ids');
                if (keyIdsStr) {
                    const keyIds = keyIdsStr.split(',').map(id => parseInt(id.trim())).filter(id => !isNaN(id));
                    if (checked) {
                        keyIds.forEach(keyId => selectedFindings.add(keyId));
                    } else {
                        keyIds.forEach(keyId => selectedFindings.delete(keyId));
                    }
                } else {
                    // Fallback to old behavior
                    const keyId = parseInt(cb.value);
                    if (checked) {
                        selectedFindings.add(keyId);
                    } else {
                        selectedFindings.delete(keyId);
                    }
                }
            });
            if (document.getElementById('selectAllCheckbox')) {
                document.getElementById('selectAllCheckbox').checked = checked;
            }
            if (document.getElementById('selectAllFindings')) {
                document.getElementById('selectAllFindings').checked = checked;
            }
        }
        
        function toggleFinding(keyId) {
            const checkbox = event.target;
            // Ensure keyId is an integer
            const keyIdInt = typeof keyId === 'string' ? parseInt(keyId) : keyId;
            if (checkbox.checked) {
                selectedFindings.add(keyIdInt);
            } else {
                selectedFindings.delete(keyIdInt);
            }
            updateSelectAllState();
        }
        
        function toggleFindingGroup(checkbox) {
            // Handle grouped findings - select/deselect all occurrences in the group
            const keyIdsStr = checkbox.getAttribute('data-key-ids');
            if (!keyIdsStr) {
                // Fallback to old behavior if data-key-ids is not present
                const keyId = parseInt(checkbox.value);
                if (checkbox.checked) {
                    selectedFindings.add(keyId);
                } else {
                    selectedFindings.delete(keyId);
                }
                updateSelectAllState();
                return;
            }
            
            const keyIds = keyIdsStr.split(',').map(id => parseInt(id.trim())).filter(id => !isNaN(id));
            if (checkbox.checked) {
                keyIds.forEach(keyId => selectedFindings.add(keyId));
            } else {
                keyIds.forEach(keyId => selectedFindings.delete(keyId));
            }
            updateSelectAllState();
        }
        
        function updateSelectAllState() {
            const checkboxes = document.querySelectorAll('.finding-checkbox');
            const allChecked = checkboxes.length > 0 && Array.from(checkboxes).every(cb => cb.checked);
            if (document.getElementById('selectAllCheckbox')) {
                document.getElementById('selectAllCheckbox').checked = allChecked;
            }
            if (document.getElementById('selectAllFindings')) {
                document.getElementById('selectAllFindings').checked = allChecked;
            }
        }
        
        async function editFinding(keyId) {
            try {
                const response = await fetch(`/api/findings/${keyId}`);
                if (!response.ok) return;
                
                const finding = await response.json();
                
                document.getElementById('editKeyId').value = finding.key_id;
                document.getElementById('editSeverity').value = finding.severity || 'medium';
                document.getElementById('editFalsePositive').checked = finding.false_positive === 1;
                document.getElementById('editVerified').checked = finding.verified === 1 || finding.verified === true;
                document.getElementById('editNotes').value = finding.notes || '';
                
                document.getElementById('editModal').classList.add('active');
            } catch (error) {
                alert('Error loading finding: ' + error.message);
            }
        }
        
        async function saveFinding(event) {
            event.preventDefault();
            
            const keyId = document.getElementById('editKeyId').value;
            const severity = document.getElementById('editSeverity').value;
            const falsePositive = document.getElementById('editFalsePositive').checked;
            const verified = document.getElementById('editVerified').checked;
            const notes = document.getElementById('editNotes').value;
            
            try {
                const response = await fetch(`/api/findings/${keyId}`, {
                    method: 'PUT',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        severity: severity,
                        false_positive: falsePositive,
                        verified: verified,
                        notes: notes
                    })
                });
                
                if (!response.ok) {
                    const error = await response.json();
                    alert('Failed to update finding: ' + (error.error || 'Unknown error'));
                    return;
                }
                
                closeModal('editModal');
                loadFindings();
                loadDashboard();
            } catch (error) {
                alert('Error updating finding: ' + error.message);
            }
        }
        
        async function deleteFinding(keyId) {
            if (!confirm('Are you sure you want to delete this finding?')) return;
            
            try {
                const response = await fetch(`/api/findings/${keyId}`, {
                    method: 'DELETE'
                });
                
                if (!response.ok) {
                    const error = await response.json();
                    alert('Failed to delete finding: ' + (error.error || 'Unknown error'));
                    return;
                }
                
                loadFindings();
                loadDashboard();
            } catch (error) {
                alert('Error deleting finding: ' + error.message);
            }
        }
        
        async function deleteFindingGroup(keyIdsStr) {
            const keyIds = keyIdsStr.split(',').map(id => parseInt(id.trim())).filter(id => !isNaN(id));
            if (keyIds.length === 0) return;
            
            const count = keyIds.length;
            if (!confirm(`Are you sure you want to delete ${count} finding${count !== 1 ? 's' : ''}?`)) return;
            
            try {
                // Delete all findings in the group
                const deletePromises = keyIds.map(keyId => 
                    fetch(`/api/findings/${keyId}`, { method: 'DELETE' })
                );
                
                const results = await Promise.all(deletePromises);
                const failed = results.filter(r => !r.ok);
                
                if (failed.length > 0) {
                    alert(`Failed to delete ${failed.length} finding${failed.length !== 1 ? 's' : ''}`);
                }
                
                loadFindings();
                loadDashboard();
            } catch (error) {
                alert('Error deleting findings: ' + error.message);
            }
        }
        
        async function bulkUpdate(field) {
            if (selectedFindings.size === 0) {
                alert('Please select at least one finding');
                return;
            }
            
            let value;
            if (field === 'severity') {
                value = prompt('Enter severity (critical, high, medium, low, info):', 'medium');
                if (!value || !['critical', 'high', 'medium', 'low', 'info'].includes(value.toLowerCase())) {
                    alert('Invalid severity');
                    return;
                }
                value = value.toLowerCase();
            } else if (field === 'false_positive') {
                value = confirm('Mark selected findings as false positive?');
            } else if (field === 'verified') {
                value = confirm('Mark selected findings as verified?');
            }
            
            try {
                const response = await fetch('/api/findings/bulk', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        key_ids: Array.from(selectedFindings),
                        updates: {[field]: value}
                    })
                });
                
                if (!response.ok) {
                    const error = await response.json();
                    alert('Failed to update findings: ' + (error.error || 'Unknown error'));
                    return;
                }
                
                loadFindings();
                loadDashboard();
                selectedFindings.clear();
                toggleSelectAll();
            } catch (error) {
                alert('Error updating findings: ' + error.message);
            }
        }
        
        async function bulkDelete() {
            if (selectedFindings.size === 0) {
                alert('Please select at least one finding');
                return;
            }
            
            // Store the selected findings before clearing
            const selectedCount = selectedFindings.size;
            const keyIdsToDelete = Array.from(selectedFindings).map(id => {
                const numId = typeof id === 'string' ? parseInt(id, 10) : id;
                if (isNaN(numId)) {
                    console.error('Invalid key ID:', id);
                    return null;
                }
                return numId;
            }).filter(id => id !== null);
            
            if (keyIdsToDelete.length === 0) {
                alert('No valid findings selected');
                selectedFindings.clear();
                return;
            }
            
            if (!confirm(`Are you sure you want to delete ${keyIdsToDelete.length} finding(s)?`)) return;
            
            try {
                console.log('Bulk deleting findings:', keyIdsToDelete);
                
                const response = await fetch('/api/findings/bulk', {
                    method: 'DELETE',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        key_ids: keyIdsToDelete
                    })
                });
                
                const result = await response.json();
                
                if (!response.ok) {
                    alert('Failed to delete findings: ' + (result.error || 'Unknown error'));
                    console.error('Bulk delete error:', result);
                    return;
                }
                
                if (result.success) {
                    const deletedCount = result.deleted || 0;
                    alert(`Successfully deleted ${deletedCount} of ${keyIdsToDelete.length} finding(s).`);
                    
                    // Clear selections before reloading
                    selectedFindings.clear();
                    
                    // Reload findings and dashboard
                    await loadFindings();
                    await loadDashboard();
                } else {
                    alert('Failed to delete findings: ' + (result.error || 'Unknown error'));
                }
            } catch (error) {
                console.error('Bulk delete exception:', error);
                alert('Error deleting findings: ' + error.message);
            }
        }
        
        function filterBySeverity(severity) {
            showPage('findings');
            document.getElementById('filterSeverity').value = severity;
            loadFindings();
        }
        
        function showFalsePositives() {
            showPage('findings');
            document.getElementById('filterFalsePositive').value = 'true';
            loadFindings();
        }
        
        function closeModal(modalId) {
            document.getElementById(modalId).classList.remove('active');
        }
        
        let modalEventSource = null;
        let modalScanId = null;
        
        function showScanOutputModal(scanId, scanTarget, event) {
            if (event) {
                event.stopPropagation();
            }
            
            modalScanId = scanId;
            document.getElementById('scanOutputModalTitle').textContent = `Scan Output: ${scanTarget}`;
            const consoleElement = document.getElementById('scanOutputModalConsole');
            consoleElement.textContent = 'Loading scan output...\n';
            
            // Close any existing EventSource
            if (modalEventSource) {
                modalEventSource.close();
                modalEventSource = null;
            }
            
            // Open modal
            document.getElementById('scanOutputModal').classList.add('active');
            
            // Start watching scan output
            watchScanInModal(scanId);
        }
        
        function watchScanInModal(scanId) {
            const consoleElement = document.getElementById('scanOutputModalConsole');
            let isFirstOutput = true;
            
            modalEventSource = new EventSource(`/api/scans/${scanId}/output`);
            
            modalEventSource.onmessage = function(event) {
                if (modalScanId !== scanId) {
                    if (modalEventSource) {
                        modalEventSource.close();
                        modalEventSource = null;
                    }
                    return;
                }
                
                try {
                    const data = JSON.parse(event.data);
                    
                    // Handle errors from server
                    if (data.error) {
                        consoleElement.textContent = `Error: ${data.error}`;
                        if (modalEventSource) {
                            modalEventSource.close();
                            modalEventSource = null;
                        }
                        return;
                    }
                    
                    // Handle output (including empty strings to confirm connection)
                    if (data.output !== undefined) {
                        if (isFirstOutput || consoleElement.textContent === 'Loading scan output...\n' || consoleElement.textContent === 'Loading scan output...') {
                            consoleElement.textContent = data.output || '';
                            isFirstOutput = false;
                        } else {
                            consoleElement.textContent += data.output || '';
                        }
                        consoleElement.scrollTop = consoleElement.scrollHeight;
                    }
                    
                    if (data.completed) {
                        if (modalEventSource) {
                            modalEventSource.close();
                            modalEventSource = null;
                        }
                        // Use debounced reload to avoid rapid requests
                        debouncedReloadScans();
                    }
                } catch (e) {
                    console.error('Error parsing SSE data:', e, event.data);
                }
            };
            
            modalEventSource.onerror = function(event) {
                if (modalScanId !== scanId) {
                    if (modalEventSource) {
                        modalEventSource.close();
                        modalEventSource = null;
                    }
                    return;
                }
                
                console.error('Modal EventSource error:', modalEventSource.readyState);
                
                // Only retry if connection was closed unexpectedly
                if (modalEventSource.readyState === EventSource.CLOSED) {
                    setTimeout(() => {
                        if (modalScanId === scanId) {
                            console.log('Reconnecting to scan output stream in modal...');
                            watchScanInModal(scanId);
                        }
                    }, 3000);
                }
            };
        }
        
        function closeScanOutputModal() {
            if (modalEventSource) {
                modalEventSource.close();
                modalEventSource = null;
            }
            modalScanId = null;
            document.getElementById('scanOutputModal').classList.remove('active');
        }
        
        function stopScanFromModal() {
            if (modalScanId) {
                stopScan(modalScanId, null);
                closeScanOutputModal();
            }
        }
        
        function showKeyOccurrencesModal(modalId, occurrencesData) {
            const modal = document.getElementById('keyOccurrencesModal');
            const keyValueEl = document.getElementById('keyOccurrencesModalKeyValue');
            const listEl = document.getElementById('keyOccurrencesModalList');
            
            if (!modal || !keyValueEl || !listEl) return;
            
            // Parse occurrences data (it comes as a JSON string from the onclick)
            let occurrences;
            try {
                if (typeof occurrencesData === 'string') {
                    occurrences = JSON.parse(occurrencesData.replace(/&quot;/g, '"'));
                } else {
                    occurrences = occurrencesData;
                }
            } catch (e) {
                console.error('Error parsing occurrences data:', e);
                return;
            }
            
            if (!occurrences || occurrences.length === 0) return;
            
            // Set the key value (from first occurrence)
            keyValueEl.textContent = occurrences[0].key_value || 'N/A';
            
            // Generate list of occurrences
            let html = '<div style="font-size: 12px; color: var(--text-secondary); margin-bottom: 8px;">Found on ' + occurrences.length + ' URL' + (occurrences.length !== 1 ? 's' : '') + ':</div>';
            
            occurrences.forEach((occ, index) => {
                const severity = occ.severity || 'medium';
                const validation = occ.validation_status || 'manual';
                const validationIcon = validation === 'valid' ? '‚úì' : (validation === 'invalid' ? '‚úó' : '?');
                const validationColor = validation === 'valid' ? 'var(--success)' : (validation === 'invalid' ? 'var(--danger)' : 'var(--warning)');
                const severityColor = severity === 'critical' ? 'var(--critical)' : 
                                      severity === 'high' ? 'var(--high)' : 
                                      severity === 'medium' ? 'var(--medium)' : 
                                      severity === 'low' ? 'var(--low)' : 'var(--info-severity)';
                
                html += `
                    <div style="background: var(--bg-secondary); padding: 12px; border-radius: 6px; margin-bottom: 8px; border-left: 3px solid ${severityColor};">
                        <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px;">
                            <div style="display: flex; align-items: center; gap: 8px; flex-wrap: wrap;">
                                <span class="severity-badge severity-${severity}">${severity}</span>
                                <span style="color: ${validationColor}; font-size: 11px;">${validationIcon} ${validation.toUpperCase()}</span>
                                ${occ.verified ? '<span style="color: var(--success); font-size: 11px;">‚úì Verified</span>' : ''}
                                ${occ.false_positive ? '<span style="color: var(--text-muted); font-size: 11px;">‚ö† False Positive</span>' : ''}
                            </div>
                            <div style="display: flex; gap: 4px;">
                                <button class="btn" onclick="editFinding(${occ.key_id})" style="font-size: 11px; padding: 4px 8px;">Edit</button>
                                <button class="btn btn-danger" onclick="deleteFinding(${occ.key_id})" style="font-size: 11px; padding: 4px 8px;">Delete</button>
                            </div>
                        </div>
                        <div style="margin-bottom: 8px;">
                            <a href="${escapeHtml(occ.url)}" target="_blank" style="font-size: 11px; color: var(--accent-secondary); text-decoration: none; word-break: break-all;">${escapeHtml(occ.url)}</a>
                        </div>
                        ${occ.notes ? `<div style="font-size: 11px; color: var(--text-secondary); font-style: italic; margin-top: 6px;">${escapeHtml(occ.notes)}</div>` : ''}
                    </div>
                `;
            });
            
            listEl.innerHTML = html;
            modal.classList.add('active');
        }
        
        function closeKeyOccurrencesModal() {
            const modal = document.getElementById('keyOccurrencesModal');
            if (modal) {
                modal.classList.remove('active');
            }
        }
        
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        let selectedTargetDomain = null;
        let selectedTargetSubdomain = null;
        
        async function loadTargets() {
            // Show loading spinner
            const targetsListEl = document.getElementById('targetsList');
            const targetsPaginationEl = document.getElementById('targetsPagination');
            if (targetsListEl) {
                targetsListEl.innerHTML = '<div class="empty-state" style="padding: 40px;"><div class="spinner" style="width: 32px; height: 32px; border-width: 3px; margin: 0 auto 16px;"></div><div style="color: var(--text-secondary);">Loading targets...</div></div>';
            }
            if (targetsPaginationEl) {
                targetsPaginationEl.innerHTML = '';
            }
            
            try {
                // Fetch both targets and results (findings) with timeout
                let targetsResponse, resultsResponse;
                try {
                    // Create abort controllers for timeout
                    const targetsController = new AbortController();
                    const resultsController = new AbortController();
                    const timeoutId1 = setTimeout(() => targetsController.abort(), 30000); // 30 second timeout
                    const timeoutId2 = setTimeout(() => resultsController.abort(), 30000);
                    
                    [targetsResponse, resultsResponse] = await Promise.all([
                        fetch('/api/targets', { signal: targetsController.signal }).finally(() => clearTimeout(timeoutId1)),
                        fetch('/api/results', { signal: resultsController.signal }).finally(() => clearTimeout(timeoutId2))
                    ]);
                } catch (fetchError) {
                    console.error('Error fetching targets:', fetchError);
                    let errorMessage = 'Failed to connect to server.';
                    if (fetchError.name === 'AbortError') {
                        errorMessage = 'Request timed out. The server may be processing a large amount of data. Please try again.';
                    } else if (fetchError.message) {
                        errorMessage = `Failed to connect: ${fetchError.message}`;
                    }
                    if (targetsListEl) {
                        targetsListEl.innerHTML = `<div class="empty-state">Error: ${errorMessage}<br><br>Please make sure the BugHunter Arsenal server is running on http://127.0.0.1:5000</div>`;
                    }
                    if (targetsPaginationEl) {
                        targetsPaginationEl.innerHTML = '';
                    }
                    return;
                }
                
                if (!targetsResponse.ok) {
                    const error = await targetsResponse.json().catch(() => ({error: 'Unknown error'}));
                    console.error('Error loading targets:', error);
                    if (targetsListEl) {
                        targetsListEl.innerHTML = `<div class="empty-state">Error loading targets: ${error.error || 'Unknown error'}</div>`;
                    }
                    if (targetsPaginationEl) {
                        targetsPaginationEl.innerHTML = '';
                    }
                    return;
                }
                
                const targetsData = await targetsResponse.json();
                const targets = targetsData.targets || [];
                
                // Get findings data
                let findingsByDomain = {};
                if (resultsResponse && resultsResponse.ok) {
                    try {
                        const resultsData = await resultsResponse.json();
                        (resultsData.domains || []).forEach(domain => {
                            findingsByDomain[domain.domain] = domain.api_keys_found || {};
                        });
                    } catch (e) {
                        console.warn('Error parsing results data:', e);
                    }
                }
                
                // Apply filters
                const filterDomain = document.getElementById('filterTargetDomain')?.value?.toLowerCase() || '';
                const minFindings = parseInt(document.getElementById('filterMinFindings')?.value || '0');
                
                let filteredTargets = targets.filter(target => {
                    const domainMatch = !filterDomain || target.domain.toLowerCase().includes(filterDomain);
                    const findingsMatch = target.total_findings >= minFindings;
                    return domainMatch && findingsMatch;
                });
                
                if (filteredTargets.length === 0) {
                    if (targetsListEl) {
                        targetsListEl.innerHTML = '<div class="empty-state">No targets found matching the filters.</div>';
                    }
                    if (targetsPaginationEl) {
                        targetsPaginationEl.innerHTML = '';
                    }
                    return;
                }
                
                // Apply pagination
                const state = paginationState.targets;
                const paginated = getPaginatedData(filteredTargets, state.currentPage, state.rowsPerPage);
                
                let targetsHTML = '';
                paginated.items.forEach(target => {
                    const subdomainCount = target.total_subdomains || 0;
                    const domainEscaped = escapeHtml(target.domain);
                    const domainJsEscaped = target.domain.replace(/\\/g, '\\\\').replace(/'/g, "\\'").replace(/\n/g, '\\n').replace(/\r/g, '\\r');
                    const targetFindings = findingsByDomain[target.domain] || {};
                    
                    // Count findings by severity
                    const severityCounts = { critical: 0, high: 0, medium: 0, low: 0, info: 0 };
                    const providerCounts = {};
                    const validationCounts = { valid: 0, invalid: 0, manual: 0 };
                    
                    Object.keys(targetFindings).forEach(url => {
                        Object.keys(targetFindings[url] || {}).forEach(provider => {
                            const keys = targetFindings[url][provider].keys || [];
                            keys.forEach(key => {
                                const severity = key.severity || 'medium';
                                severityCounts[severity] = (severityCounts[severity] || 0) + 1;
                                providerCounts[provider] = (providerCounts[provider] || 0) + 1;
                                const validation = key.validation_status || 'manual';
                                validationCounts[validation] = (validationCounts[validation] || 0) + 1;
                            });
                        });
                    });
                    
                    targetsHTML += `
                        <div class="domain-card" data-domain="${domainEscaped}" style="cursor: pointer; transition: all 0.2s;" onclick="viewTarget('${domainJsEscaped}')" onmouseover="this.style.background='var(--bg-tertiary)'" onmouseout="this.style.background='var(--bg-card)'">
                            <div class="domain-header" style="padding: 16px;">
                                <div style="flex: 1;">
                                    <div class="domain-name">${escapeHtml(target.domain)}</div>
                                    <div class="domain-stats">
                                        <span style="color: var(--accent-primary); font-weight: 600;">${target.total_findings} Finding${target.total_findings !== 1 ? 's' : ''}</span>
                                        ${target.total_findings > 0 ? ` ‚Ä¢ ` : ''}
                                        ${target.total_findings > 0 ? `<span style="color: var(--critical);">${severityCounts.critical || 0} Critical</span>` : ''}
                                        ${severityCounts.critical > 0 && severityCounts.high > 0 ? ' ‚Ä¢ ' : ''}
                                        ${severityCounts.high > 0 ? `<span style="color: var(--high);">${severityCounts.high} High</span>` : ''}
                                        ${(severityCounts.critical > 0 || severityCounts.high > 0) && severityCounts.medium > 0 ? ' ‚Ä¢ ' : ''}
                                        ${severityCounts.medium > 0 ? `<span style="color: var(--medium);">${severityCounts.medium} Medium</span>` : ''}
                                        ${target.total_findings > 0 ? ` ‚Ä¢ ` : ''}
                                        ${subdomainCount} Subdomain${subdomainCount !== 1 ? 's' : ''} ‚Ä¢ 
                                        ${target.total_urls} URL${target.total_urls !== 1 ? 's' : ''}
                                    </div>
                                </div>
                                <div style="display: flex; align-items: center; gap: 8px;" onclick="event.stopPropagation()">
                                    <button class="btn btn-primary btn-stop" onclick="viewTarget('${domainJsEscaped}'); event.stopPropagation();" title="View details">üëÅÔ∏è View</button>
                                    <button class="btn btn-danger btn-stop" onclick="deleteTargetDomain('${domainJsEscaped}', event)" title="Delete this domain">üóëÔ∏è Delete</button>
                                </div>
                            </div>
                        </div>
                    `;
                });
                
                if (targetsListEl) {
                    targetsListEl.innerHTML = targetsHTML;
                }
                
                // Render pagination
                renderPagination('targetsPagination', paginated, null, null, 'targets');
            } catch (error) {
                console.error('Error loading targets:', error);
                const errorMessage = error.message || 'Unknown error';
                let userMessage = 'Error loading targets';
                
                if (errorMessage.includes('Failed to fetch') || errorMessage.includes('NetworkError')) {
                    userMessage = 'Failed to connect to server. Please make sure the BugHunter Arsenal server is running on http://127.0.0.1:5000';
                } else {
                    userMessage = `Error loading targets: ${errorMessage}`;
                }
                
                if (targetsListEl) {
                    targetsListEl.innerHTML = `<div class="empty-state">${userMessage}</div>`;
                }
                if (targetsPaginationEl) {
                    targetsPaginationEl.innerHTML = '';
                }
            }
        }
        
        function generateTargetFindings(domain, findings, subdomains, targetUrls) {
            const domainId = domain.replace(/[^a-zA-Z0-9]/g, '_');
            let html = '<div style="padding: 16px;">';
            
            // Calculate stats
            const severityCounts = { critical: 0, high: 0, medium: 0, low: 0, info: 0 };
            const providerCounts = {};
            const validationCounts = { valid: 0, invalid: 0, manual: 0 };
            let totalFindings = 0;
            const allUrls = new Set();
            
            if (findings && Object.keys(findings).length > 0) {
                Object.keys(findings).forEach(url => {
                    allUrls.add(url);
                    Object.keys(findings[url] || {}).forEach(provider => {
                        const keys = findings[url][provider].keys || [];
                        keys.forEach(key => {
                            totalFindings++;
                            const severity = key.severity || 'medium';
                            severityCounts[severity] = (severityCounts[severity] || 0) + 1;
                            providerCounts[provider] = (providerCounts[provider] || 0) + 1;
                            const validation = key.validation_status || 'manual';
                            validationCounts[validation] = (validationCounts[validation] || 0) + 1;
                        });
                    });
                });
            }
            
            // Add URLs from targetUrls if available
            if (targetUrls && targetUrls.length > 0) {
                targetUrls.forEach(urlObj => {
                    if (urlObj.url) allUrls.add(urlObj.url);
                });
            }
            
            // APIs Section
            html += `
                <div class="target-section" style="margin-bottom: 16px;">
                    <div class="target-section-header" onclick="toggleTargetSection('${domainId}-apis')" style="cursor: pointer; padding: 12px; background: var(--bg-secondary); border-radius: 6px; display: flex; align-items: center; justify-content: space-between;">
                        <div style="display: flex; align-items: center; gap: 12px;">
                            <span class="toggle-icon" id="${domainId}-apis-icon">‚ñ∂</span>
                            <span style="font-weight: 600; color: var(--accent-primary);">üîë APIs</span>
                            <span style="font-size: 12px; color: var(--text-secondary);">(${totalFindings} finding${totalFindings !== 1 ? 's' : ''})</span>
                        </div>
                    </div>
                    <div class="target-section-content" id="${domainId}-apis" style="display: none; padding: 12px; background: var(--bg-tertiary); border-radius: 6px; margin-top: 8px;">
                        ${totalFindings === 0 ? '<div class="empty-state">No API findings for this target</div>' : generateAPISection(findings, domainId)}
                    </div>
                </div>
            `;
            
            // URLs Section
            html += `
                <div class="target-section" style="margin-bottom: 16px;">
                    <div class="target-section-header" onclick="toggleTargetSection('${domainId}-urls')" style="cursor: pointer; padding: 12px; background: var(--bg-secondary); border-radius: 6px; display: flex; align-items: center; justify-content: space-between;">
                        <div style="display: flex; align-items: center; gap: 12px;">
                            <span class="toggle-icon" id="${domainId}-urls-icon">‚ñ∂</span>
                            <span style="font-weight: 600; color: var(--accent-secondary);">üîó URLs</span>
                            <span style="font-size: 12px; color: var(--text-secondary);">(${allUrls.size} URL${allUrls.size !== 1 ? 's' : ''})</span>
                        </div>
                    </div>
                    <div class="target-section-content" id="${domainId}-urls" style="display: none; padding: 12px; background: var(--bg-tertiary); border-radius: 6px; margin-top: 8px;">
                        ${allUrls.size === 0 ? '<div class="empty-state">No URLs found for this target</div>' : generateURLsSection(Array.from(allUrls), targetUrls)}
                    </div>
                </div>
            `;
            
            // SUBS Section
            html += `
                <div class="target-section" style="margin-bottom: 16px;">
                    <div class="target-section-header" onclick="toggleTargetSection('${domainId}-subs')" style="cursor: pointer; padding: 12px; background: var(--bg-secondary); border-radius: 6px; display: flex; align-items: center; justify-content: space-between;">
                        <div style="display: flex; align-items: center; gap: 12px;">
                            <span class="toggle-icon" id="${domainId}-subs-icon">‚ñ∂</span>
                            <span style="font-weight: 600; color: var(--info);">üåê SUBS</span>
                            <span style="font-size: 12px; color: var(--text-secondary);">(${subdomains.length} subdomain${subdomains.length !== 1 ? 's' : ''})</span>
                        </div>
                    </div>
                    <div class="target-section-content" id="${domainId}-subs" style="display: none; padding: 12px; background: var(--bg-tertiary); border-radius: 6px; margin-top: 8px;">
                        ${subdomains.length === 0 ? '<div class="empty-state">No subdomains found for this target</div>' : generateSubsSection(subdomains, domain)}
                    </div>
                </div>
            `;
            
            // XSSs Section (placeholder for future)
            html += `
                <div class="target-section" style="margin-bottom: 16px;">
                    <div class="target-section-header" onclick="toggleTargetSection('${domainId}-xss')" style="cursor: pointer; padding: 12px; background: var(--bg-secondary); border-radius: 6px; display: flex; align-items: center; justify-content: space-between;">
                        <div style="display: flex; align-items: center; gap: 12px;">
                            <span class="toggle-icon" id="${domainId}-xss-icon">‚ñ∂</span>
                            <span style="font-weight: 600; color: var(--warning);">‚ö†Ô∏è XSSs</span>
                            <span style="font-size: 12px; color: var(--text-muted);">(Coming soon)</span>
                        </div>
                    </div>
                    <div class="target-section-content" id="${domainId}-xss" style="display: none; padding: 12px; background: var(--bg-tertiary); border-radius: 6px; margin-top: 8px;">
                        <div class="empty-state">XSS scanning feature coming soon</div>
                    </div>
                </div>
            `;
            
            html += '</div>';
            return html;
        }
        
        function generateAPISection(findings, domainId) {
            if (!findings || Object.keys(findings).length === 0) {
                return '<div class="empty-state">No API findings</div>';
            }
            
            // Group by provider first
            const findingsByProvider = {};
            Object.keys(findings).forEach(url => {
                Object.keys(findings[url] || {}).forEach(provider => {
                    if (!findingsByProvider[provider]) {
                        findingsByProvider[provider] = [];
                    }
                    const keys = findings[url][provider].keys || [];
                    keys.forEach(key => {
                        findingsByProvider[provider].push({...key, url});
                    });
                });
            });
            
            let html = '';
            Object.keys(findingsByProvider).sort().forEach(provider => {
                const providerFindings = findingsByProvider[provider];
                const providerId = `${domainId}-provider-${provider.replace(/[^a-zA-Z0-9]/g, '_')}`;
                
                html += `
                    <div style="margin-bottom: 16px; background: var(--bg-card); padding: 12px; border-radius: 6px; border-left: 3px solid var(--accent-primary);">
                        <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px;">
                            <div style="display: flex; align-items: center; gap: 8px; cursor: pointer;" onclick="toggleTargetSection('${providerId}')">
                                <span class="toggle-icon" id="${providerId}-icon">‚ñ∂</span>
                                <span style="font-weight: 600; color: var(--accent-primary);">${escapeHtml(provider)}</span>
                                <span style="font-size: 12px; color: var(--text-secondary);">(${providerFindings.length} key${providerFindings.length !== 1 ? 's' : ''})</span>
                            </div>
                        </div>
                        <div class="target-section-content" id="${providerId}" style="display: none; margin-top: 8px;">
                            ${providerFindings.map(key => {
                                const severity = key.severity || 'medium';
                                const validation = key.validation_status || 'manual';
                                const validationIcon = validation === 'valid' ? '‚úì' : (validation === 'invalid' ? '‚úó' : '?');
                                const validationColor = validation === 'valid' ? 'var(--success)' : (validation === 'invalid' ? 'var(--danger)' : 'var(--warning)');
                                const severityColor = severity === 'critical' ? 'var(--critical)' : 
                                                      severity === 'high' ? 'var(--high)' : 
                                                      severity === 'medium' ? 'var(--medium)' : 
                                                      severity === 'low' ? 'var(--low)' : 'var(--info-severity)';
                                
                                return `
                                    <div style="background: var(--bg-tertiary); padding: 10px; border-radius: 6px; margin-bottom: 8px; border-left: 3px solid ${severityColor};">
                                        <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 6px;">
                                            <div style="display: flex; align-items: center; gap: 8px; flex-wrap: wrap;">
                                                <span class="severity-badge severity-${severity}">${severity}</span>
                                                <span style="color: ${validationColor}; font-size: 12px;">${validationIcon} ${validation.toUpperCase()}</span>
                                                ${key.verified ? '<span style="color: var(--success); font-size: 11px;">‚úì Verified</span>' : ''}
                                                ${key.false_positive ? '<span style="color: var(--text-muted); font-size: 11px;">‚ö† False Positive</span>' : ''}
                                                <a href="${escapeHtml(key.url)}" target="_blank" style="font-size: 11px; color: var(--accent-secondary); text-decoration: none;">${escapeHtml(key.url)}</a>
                                            </div>
                                            <div style="display: flex; gap: 4px;">
                                                <button class="btn" onclick="editFinding(${key.key_id})" style="font-size: 11px; padding: 4px 8px;">Edit</button>
                                                <button class="btn btn-danger" onclick="deleteFinding(${key.key_id})" style="font-size: 11px; padding: 4px 8px;">Delete</button>
                                            </div>
                                        </div>
                                        <div style="font-family: monospace; font-size: 11px; color: var(--text-secondary); word-break: break-all; background: var(--bg-primary); padding: 8px; border-radius: 4px;">
                                            ${escapeHtml(key.key_value)}
                                        </div>
                                        ${key.notes ? `<div style="font-size: 11px; color: var(--text-secondary); margin-top: 6px; font-style: italic;">${escapeHtml(key.notes)}</div>` : ''}
                                    </div>
                                `;
                            }).join('')}
                        </div>
                    </div>
                `;
            });
            
            return html;
        }
        
        function generateURLsSection(urls, targetUrls) {
            let html = '';
            urls.forEach(url => {
                const urlObj = targetUrls?.find(u => u.url === url);
                html += `
                    <div style="padding: 8px; background: var(--bg-card); border-radius: 4px; margin-bottom: 8px; display: flex; align-items: center; justify-content: space-between;">
                        <a href="${escapeHtml(url)}" target="_blank" class="url-link">${escapeHtml(url)}</a>
                        ${urlObj?.status_code ? `<span style="font-size: 11px; color: var(--text-muted); margin-left: 8px;">[${urlObj.status_code}]</span>` : ''}
                    </div>
                `;
            });
            return html;
        }
        
        function generateSubsSection(subdomains, domain) {
            const domainJsEscaped = domain.replace(/\\/g, '\\\\').replace(/'/g, "\\'").replace(/\n/g, '\\n').replace(/\r/g, '\\r');
            let html = '';
            subdomains.forEach((subdomain, index) => {
                const urls = subdomain.urls || [];
                const subdomainEscaped = escapeHtml(subdomain.subdomain);
                const subdomainJsEscaped = subdomain.subdomain.replace(/\\/g, '\\\\').replace(/'/g, "\\'").replace(/\n/g, '\\n').replace(/\r/g, '\\r');
                const subdomainId = `subdomain-${domain.replace(/[^a-zA-Z0-9]/g, '_')}-${index}`;
                
                html += `
                    <div style="background: var(--bg-card); padding: 12px; border-radius: 6px; margin-bottom: 8px;">
                        <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px;">
                            <div style="display: flex; align-items: center; gap: 12px; cursor: pointer;" onclick="toggleSubdomain('${subdomainId}')">
                                <span class="toggle-icon" id="${subdomainId}-icon">‚ñ∂</span>
                                <strong style="color: var(--accent-primary);">${escapeHtml(subdomain.subdomain)}</strong>
                                <span style="font-size: 11px; color: var(--text-secondary);">${urls.length} URL${urls.length !== 1 ? 's' : ''}</span>
                            </div>
                            <div style="display: flex; gap: 8px;">
                                <button class="btn btn-primary btn-stop" onclick="exportTargetSubdomain('${domainJsEscaped}', '${subdomainJsEscaped}', event); event.stopPropagation();">üì• Export</button>
                                <button class="btn btn-danger btn-stop" onclick="deleteTargetSubdomain('${domainJsEscaped}', '${subdomainJsEscaped}', event); event.stopPropagation();">üóëÔ∏è Delete</button>
                            </div>
                        </div>
                        <div class="subdomain-urls" id="${subdomainId}-urls" style="display: none; padding-left: 32px;">
                            ${urls.map(url => {
                                return `
                                    <div style="padding: 8px; background: var(--bg-tertiary); border-radius: 4px; margin-bottom: 8px;">
                                        <a href="${escapeHtml(url.url)}" target="_blank" class="url-link">${escapeHtml(url.url)}</a>
                                        ${url.status_code ? `<span style="font-size: 10px; color: var(--text-muted); margin-left: 8px;">[${url.status_code}]</span>` : ''}
                                    </div>
                                `;
                            }).join('')}
                        </div>
                    </div>
                `;
            });
            return html;
        }
        
        function toggleTargetSection(sectionId) {
            const section = document.getElementById(sectionId);
            const icon = document.getElementById(`${sectionId}-icon`);
            
            if (section && icon) {
                const isVisible = section.style.display !== 'none';
                section.style.display = isVisible ? 'none' : 'block';
                icon.textContent = isVisible ? '‚ñ∂' : '‚ñº';
                icon.classList.toggle('open');
            }
        }
        
        function getAllTargetUrls(subdomains, findings) {
            const urls = [];
            const urlSet = new Set();
            
            // Collect URLs from subdomains
            subdomains.forEach(subdomain => {
                if (subdomain.urls && subdomain.urls.length > 0) {
                    subdomain.urls.forEach(urlObj => {
                        if (urlObj.url && !urlSet.has(urlObj.url)) {
                            urls.push(urlObj);
                            urlSet.add(urlObj.url);
                        }
                    });
                }
            });
            
            // Collect URLs from findings
            if (findings && Object.keys(findings).length > 0) {
                Object.keys(findings).forEach(url => {
                    if (!urlSet.has(url)) {
                        urls.push({url: url});
                        urlSet.add(url);
                    }
                });
            }
            
            return urls;
        }
        
        function toggleTarget(element) {
            const domainCard = element.closest('.domain-card');
            const urlList = domainCard.querySelector('.url-list');
            const icon = domainCard.querySelector('.toggle-icon');
            const isActive = urlList.classList.contains('active');
            
            urlList.classList.toggle('active');
            icon.classList.toggle('open');
            icon.textContent = isActive ? '‚ñ∂' : '‚ñº';
        }
        
        function generateTargetSubdomains(subdomains, domain) {
            if (!subdomains || subdomains.length === 0) {
                return '<div class="empty-state" style="margin-top: 16px;">No subdomains found</div>';
            }
            
            let html = '<div style="margin-top: 16px;"><div style="font-size: 12px; color: var(--text-muted); text-transform: uppercase; margin-bottom: 12px;">Subdomains</div>';
            subdomains.forEach((subdomain, index) => {
                const urls = subdomain.urls || [];
                const subdomainEscaped = escapeHtml(subdomain.subdomain);
                const subdomainJsEscaped = subdomain.subdomain.replace(/\\/g, '\\\\').replace(/'/g, "\\'").replace(/\n/g, '\\n').replace(/\r/g, '\\r');
                const domainJsEscaped = domain.replace(/\\/g, '\\\\').replace(/'/g, "\\'").replace(/\n/g, '\\n').replace(/\r/g, '\\r');
                const subdomainId = `subdomain-${domain.replace(/[^a-zA-Z0-9]/g, '_')}-${index}`;
                
                html += `
                    <div class="subdomain-item" style="background: var(--bg-secondary); border-radius: 6px; padding: 12px; margin-bottom: 8px;">
                        <div class="subdomain-header" onclick="toggleSubdomain('${subdomainId}')" style="cursor: pointer;">
                            <div style="display: flex; align-items: center; justify-content: space-between;">
                                <div style="display: flex; align-items: center; gap: 12px;">
                                    <span class="toggle-icon" id="${subdomainId}-icon">‚ñ∂</span>
                                    <div>
                                        <strong style="color: var(--accent-primary);">${escapeHtml(subdomain.subdomain)}</strong>
                                        <span style="font-size: 11px; color: var(--text-secondary); margin-left: 12px;">
                                            ${urls.length} URL${urls.length !== 1 ? 's' : ''}
                                        </span>
                                    </div>
                                </div>
                                <div style="display: flex; gap: 8px;">
                                    <button class="btn btn-primary btn-stop" onclick="exportTargetSubdomain('${domainJsEscaped}', '${subdomainJsEscaped}', event); event.stopPropagation();">üì• Export</button>
                                    <button class="btn btn-danger btn-stop" onclick="deleteTargetSubdomain('${domainJsEscaped}', '${subdomainJsEscaped}', event); event.stopPropagation();" title="Delete this subdomain">üóëÔ∏è Delete</button>
                                </div>
                            </div>
                        </div>
                        <div class="subdomain-urls" id="${subdomainId}-urls" style="display: none; margin-top: 12px; padding-left: 32px;">
                            ${urls.map(url => {
                                return `
                                    <div style="padding: 8px; background: var(--bg-tertiary); border-radius: 4px; margin-bottom: 8px;">
                                        <div>
                                            <a href="${escapeHtml(url.url)}" target="_blank" class="url-link">${escapeHtml(url.url)}</a>
                                            ${url.status_code ? `<span style="font-size: 10px; color: var(--text-muted); margin-left: 8px;">[${url.status_code}]</span>` : ''}
                                        </div>
                                    </div>
                                `;
                            }).join('')}
                        </div>
                    </div>
                `;
            });
            html += '</div>';
            return html;
        }
        
        function toggleSubdomain(subdomainId) {
            const urlsDiv = document.getElementById(`${subdomainId}-urls`);
            const icon = document.getElementById(`${subdomainId}-icon`);
            
            if (urlsDiv && icon) {
                const isActive = urlsDiv.classList.contains('active');
                urlsDiv.classList.toggle('active');
                urlsDiv.style.display = isActive ? 'none' : 'block';
                icon.classList.toggle('open');
                icon.textContent = isActive ? '‚ñ∂' : '‚ñº';
            }
        }
        
        async function deleteTargetDomain(domain, event) {
            if (event) {
                event.stopPropagation();
            }
            
            if (!confirm(`‚ö†Ô∏è WARNING: This will permanently delete domain "${domain}" and ALL associated data:\n\n‚Ä¢ All scan results for this domain\n‚Ä¢ All subdomains for this domain\n‚Ä¢ All URLs found for this domain\n‚Ä¢ All API keys found for this domain\n\nThis action cannot be undone!\n\nAre you sure you want to proceed?`)) {
                return;
            }
            
            if (!confirm(`Last chance! Are you absolutely sure you want to delete "${domain}" and purge all its data?`)) {
                return;
            }
            
            try {
                const encodedDomain = encodeURIComponent(domain);
                const response = await fetch(`/api/scans/by-domain/${encodedDomain}`, {
                    method: 'DELETE'
                });
                
                if (!response.ok) {
                    const error = await response.json();
                    alert('Failed to delete domain: ' + (error.error || 'Unknown error'));
                    return;
                }
                
                const data = await response.json();
                alert(`Domain "${domain}" deleted successfully.\n\nDeleted:\n‚Ä¢ ${data.scans_deleted} scan(s)\n‚Ä¢ ${data.urls_deleted} URL(s)\n‚Ä¢ ${data.keys_deleted} API key(s)`);
                
                await loadTargets();
                await loadDashboard();
                await loadFindings();
            } catch (error) {
                alert('Error deleting domain: ' + error.message);
            }
        }
        
        async function deleteTargetSubdomain(domain, subdomain, event) {
            if (event) {
                event.stopPropagation();
            }
            
            if (!confirm(`‚ö†Ô∏è WARNING: This will permanently delete subdomain "${subdomain}" and ALL associated data:\n\n‚Ä¢ All URLs found for this subdomain\n‚Ä¢ All API keys found for this subdomain\n\nThis action cannot be undone!\n\nAre you sure you want to proceed?`)) {
                return;
            }
            
            try {
                const response = await fetch('/api/targets/subdomain', {
                    method: 'DELETE',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        domain: domain,
                        subdomain: subdomain
                    })
                });
                
                if (!response.ok) {
                    const error = await response.json();
                    alert('Failed to delete subdomain: ' + (error.error || 'Unknown error'));
                    return;
                }
                
                const data = await response.json();
                alert(`Subdomain "${subdomain}" deleted successfully.\n\nDeleted:\n‚Ä¢ ${data.urls_deleted} URL(s)\n‚Ä¢ ${data.keys_deleted} API key(s)`);
                
                await loadTargets();
                await loadDashboard();
                await loadFindings();
            } catch (error) {
                alert('Error deleting subdomain: ' + error.message);
            }
        }
        
        function getPaginatedData(data, currentPage, rowsPerPage) {
            const start = (currentPage - 1) * rowsPerPage;
            const end = start + rowsPerPage;
            return {
                items: data.slice(start, end),
                total: data.length,
                totalPages: Math.ceil(data.length / rowsPerPage),
                currentPage: currentPage,
                rowsPerPage: rowsPerPage
            };
        }
        
        function renderPagination(containerId, paginationData, onPageChangeCallback, onRowsPerPageChangeCallback, stateKey) {
            const container = document.getElementById(containerId);
            if (!container) return;
            
            const { total, totalPages, currentPage, rowsPerPage } = paginationData;
            const start = total === 0 ? 0 : (currentPage - 1) * rowsPerPage + 1;
            const end = Math.min(currentPage * rowsPerPage, total);
            
            let html = '<div class="pagination">';
            html += '<div class="pagination-info">';
            html += `<span>Showing ${start} to ${end} of ${total} entries</span>`;
            html += '<div class="rows-per-page">';
            html += '<span>Rows per page:</span>';
            html += `<select onchange="changeRowsPerPage('${stateKey}', parseInt(this.value))">`;
            [25, 50, 100, 200].forEach(rows => {
                html += `<option value="${rows}" ${rows === rowsPerPage ? 'selected' : ''}>${rows}</option>`;
            });
            html += '</select>';
            html += '</div>';
            html += '</div>';
            
            html += '<div class="pagination-controls">';
            
            // First page
            html += `<button class="pagination-btn" onclick="changePage('${stateKey}', 1)" ${currentPage === 1 ? 'disabled' : ''}>First</button>`;
            
            // Previous page
            html += `<button class="pagination-btn" onclick="changePage('${stateKey}', ${currentPage - 1})" ${currentPage === 1 ? 'disabled' : ''}>Previous</button>`;
            
            // Page numbers
            const maxVisiblePages = 5;
            let startPage = Math.max(1, currentPage - Math.floor(maxVisiblePages / 2));
            let endPage = Math.min(totalPages, startPage + maxVisiblePages - 1);
            
            if (endPage - startPage < maxVisiblePages - 1) {
                startPage = Math.max(1, endPage - maxVisiblePages + 1);
            }
            
            if (startPage > 1) {
                html += `<button class="pagination-btn" onclick="changePage('${stateKey}', 1)">1</button>`;
                if (startPage > 2) {
                    html += `<span style="color: var(--text-secondary); padding: 0 4px;">...</span>`;
                }
            }
            
            for (let i = startPage; i <= endPage; i++) {
                html += `<button class="pagination-btn ${i === currentPage ? 'active' : ''}" onclick="changePage('${stateKey}', ${i})">${i}</button>`;
            }
            
            if (endPage < totalPages) {
                if (endPage < totalPages - 1) {
                    html += `<span style="color: var(--text-secondary); padding: 0 4px;">...</span>`;
                }
                html += `<button class="pagination-btn" onclick="changePage('${stateKey}', ${totalPages})">${totalPages}</button>`;
            }
            
            // Next page
            html += `<button class="pagination-btn" onclick="changePage('${stateKey}', ${currentPage + 1})" ${currentPage === totalPages ? 'disabled' : ''}>Next</button>`;
            
            // Last page
            html += `<button class="pagination-btn" onclick="changePage('${stateKey}', ${totalPages})" ${currentPage === totalPages ? 'disabled' : ''}>Last</button>`;
            
            html += '</div>';
            html += '</div>';
            
            container.innerHTML = html;
        }
        
        function changePage(stateKey, page) {
            paginationState[stateKey].currentPage = page;
            
            if (stateKey === 'findings') {
                loadFindings();
            } else if (stateKey === 'targets') {
                loadTargets();
            } else if (stateKey === 'scans') {
                loadScans();
            } else if (stateKey === 'recentFindings') {
                loadDashboard();
            }
        }
        
        function changeRowsPerPage(stateKey, rowsPerPage) {
            paginationState[stateKey].rowsPerPage = rowsPerPage;
            paginationState[stateKey].currentPage = 1; // Reset to first page
            
            if (stateKey === 'findings') {
                loadFindings();
            } else if (stateKey === 'targets') {
                loadTargets();
            } else if (stateKey === 'scans') {
                loadScans();
            } else if (stateKey === 'recentFindings') {
                loadDashboard();
            }
        }
        
        async function exportTargetDomain(domain, event) {
            if (event) {
                event.stopPropagation();
            }
            
            // Get default format and export type from dropdowns or use defaults
            const formatSelect = document.getElementById('exportFormat');
            const exportTypeSelect = document.getElementById('exportType');
            const format = formatSelect ? formatSelect.value : 'json';
            const exportType = exportTypeSelect ? exportTypeSelect.value : 'urls';
            
            await performExport('target', format, domain, null, exportType);
        }
        
        async function exportTargetSubdomain(domain, subdomain, event) {
            if (event) {
                event.stopPropagation();
            }
            
            // Get default format and export type from dropdowns or use defaults
            const formatSelect = document.getElementById('exportFormat');
            const exportTypeSelect = document.getElementById('exportType');
            const format = formatSelect ? formatSelect.value : 'json';
            const exportType = exportTypeSelect ? exportTypeSelect.value : 'urls';
            
            await performExport('subdomain', format, domain, subdomain, exportType);
        }
        
        async function performExport(scope, format, targetDomain, targetSubdomain, exportType = 'urls') {
            const exportData = {
                format: format,
                scope: scope,
                export_type: exportType
            };
            
            if (scope === 'target' && targetDomain) {
                exportData.target_domain = targetDomain;
            } else if (scope === 'subdomain' && targetSubdomain) {
                exportData.target_domain = targetDomain;
                exportData.target_subdomain = targetSubdomain;
            }
            
            try {
                const statusEl = document.getElementById('exportStatus');
                if (statusEl) statusEl.textContent = 'Exporting...';
                
                const response = await fetch('/api/targets/export', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify(exportData)
                });
                
                if (!response.ok) {
                    const error = await response.json();
                    const errorMsg = error.error || 'Unknown error';
                    if (statusEl) statusEl.textContent = 'Export failed: ' + errorMsg;
                    alert('Failed to export: ' + errorMsg);
                    return;
                }
                
                if (format === 'json') {
                    const data = await response.json();
                    const blob = new Blob([JSON.stringify(data.data, null, 2)], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    const scopeName = scope === 'target' ? targetDomain : (scope === 'subdomain' ? targetSubdomain : 'all');
                    a.download = `targets_export_${exportType}_${scopeName}_${Date.now()}.json`;
                    a.click();
                    URL.revokeObjectURL(url);
                } else {
                    const blob = await response.blob();
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    const extension = format === 'csv' ? 'csv' : 'txt';
                    const scopeName = scope === 'target' ? targetDomain : (scope === 'subdomain' ? targetSubdomain : 'all');
                    a.download = `targets_export_${exportType}_${scopeName}_${Date.now()}.${extension}`;
                    a.click();
                    URL.revokeObjectURL(url);
                }
                
                if (statusEl) statusEl.textContent = 'Export completed successfully!';
                setTimeout(() => { if (statusEl) statusEl.textContent = ''; }, 3000);
            } catch (error) {
                const statusEl = document.getElementById('exportStatus');
                if (statusEl) statusEl.textContent = 'Export error: ' + error.message;
                alert('Error exporting targets: ' + error.message);
            }
        }
        
        function selectTargetForExport(domain, subdomain, event) {
            if (event) {
                event.stopPropagation();
            }
            selectedTargetDomain = domain;
            selectedTargetSubdomain = subdomain;
            
            // Update export scope dropdown
            const scopeSelect = document.getElementById('exportScope');
            if (subdomain) {
                scopeSelect.value = 'subdomain';
            } else if (domain) {
                scopeSelect.value = 'target';
            } else {
                scopeSelect.value = 'all';
            }
            
            // Scroll to export section
            document.querySelector('.card-header').scrollIntoView({ behavior: 'smooth', block: 'start' });
        }
        
        async function exportTargets() {
            const format = document.getElementById('exportFormat').value;
            const scope = document.getElementById('exportScope').value;
            const exportType = document.getElementById('exportType').value;
            
            await performExport(scope, format, selectedTargetDomain, selectedTargetSubdomain, exportType);
        }
        
        function refreshData() {
            if (currentPage === 'dashboard') loadDashboard();
            else if (currentPage === 'findings') loadFindings();
            else if (currentPage === 'scans') loadScans();
            else if (currentPage === 'targets') loadTargets();
        }
        
        async function loadInitialStats() {
            try {
                const response = await fetch('/api/stats');
                if (response.ok) {
                    const stats = await response.json();
                    updateStatsCards(stats);
                }
            } catch (e) {
                console.error('Error loading initial stats:', e);
            }
        }
        
        function startStatsStream() {
            if (statsEventSource) {
                statsEventSource.close();
            }
            
            statsEventSource = new EventSource('/api/stats/stream');
            
            statsEventSource.onmessage = function(event) {
                try {
                    const stats = JSON.parse(event.data);
                    updateStatsCards(stats);
                } catch (e) {
                    console.error('Error parsing stats:', e);
                }
            };
            
            statsEventSource.onerror = function(event) {
                console.error('Stats stream error:', event);
                // Reconnect after 3 seconds
                setTimeout(() => {
                    if (statsEventSource && statsEventSource.readyState === EventSource.CLOSED) {
                        startStatsStream();
                    }
                }, 3000);
            };
        }
        
        function updateStatsCards(stats) {
            const statsGrid = document.getElementById('statsGrid');
            if (!statsGrid) return;
            
            const statsHTML = `
                <div class="stat-card" onclick="showPage('targets')" title="Click to view targets">
                    <div class="stat-value">${stats.total_domains || 0}</div>
                    <div class="stat-label">Targets</div>
                </div>
                <div class="stat-card" onclick="showPage('targets')" title="Click to view targets (subdomains shown on target details)">
                    <div class="stat-value">${stats.total_subdomains || 0}</div>
                    <div class="stat-label">Subdomains</div>
                </div>
                <div class="stat-card" onclick="showPage('targets')" title="Click to view targets (URLs shown on target details)">
                    <div class="stat-value">${stats.total_urls || 0}</div>
                    <div class="stat-label">URLs</div>
                </div>
                <div class="stat-card" onclick="showPage('findings')" title="Click to view findings">
                    <div class="stat-value">${stats.total_keys || 0}</div>
                    <div class="stat-label">Findings</div>
                </div>
            `;
            
            statsGrid.innerHTML = statsHTML;
            
            // Update system stats if available
            if (stats.system) {
                updateSystemStatsCards(stats.system);
            }
        }
        
        function updateSystemStatsCards(systemStats) {
            const systemStatsGrid = document.getElementById('systemStatsGrid');
            if (!systemStatsGrid || !systemStats) return;
            
            const cpu = systemStats.cpu || {};
            const ram = systemStats.ram || {};
            const network = systemStats.network || {};
            const outputFolder = systemStats.output_folder || {};
            
            // Determine progress bar class based on usage
            const getProgressClass = (percent) => {
                if (percent >= 90) return 'danger';
                if (percent >= 70) return 'warning';
                return '';
            };
            
            const formatBytes = (sizeBytes) => {
                if (sizeBytes === 0) return '0 B';
                if (sizeBytes < 1024) return `${sizeBytes.toFixed(2)} B`;
                if (sizeBytes < 1024 * 1024) return `${(sizeBytes / 1024).toFixed(2)} KB`;
                if (sizeBytes < 1024 * 1024 * 1024) return `${(sizeBytes / (1024 * 1024)).toFixed(2)} MB`;
                return `${(sizeBytes / (1024 * 1024 * 1024)).toFixed(2)} GB`;
            };
            
            const formatBytesFromGB = (gb, unit = 'GB') => {
                if (unit === 'GB') {
                    return gb >= 1 ? `${gb.toFixed(2)} GB` : gb >= 0.001 ? `${(gb * 1024).toFixed(2)} MB` : `${(gb * 1024 * 1024).toFixed(2)} KB`;
                }
                return gb >= 1024 ? `${(gb / 1024).toFixed(2)} GB` : `${gb.toFixed(2)} MB`;
            };
            
            const statsHTML = `
                <div class="system-stat-card">
                    <div class="system-stat-header">
                        <div class="system-stat-label">CPU Usage</div>
                    </div>
                    <div class="system-stat-value">${cpu.percent || 0}%</div>
                    <div class="system-stat-detail">${cpu.count || 0} cores</div>
                    <div class="progress-bar">
                        <div class="progress-fill ${getProgressClass(cpu.percent || 0)}" style="width: ${cpu.percent || 0}%"></div>
                    </div>
                </div>
                
                <div class="system-stat-card">
                    <div class="system-stat-header">
                        <div class="system-stat-label">RAM Usage</div>
                    </div>
                    <div class="system-stat-value">${ram.percent || 0}%</div>
                    <div class="system-stat-detail">${formatBytesFromGB(ram.used_gb || 0)} / ${formatBytesFromGB(ram.total_gb || 0)}</div>
                    <div class="progress-bar">
                        <div class="progress-fill ${getProgressClass(ram.percent || 0)}" style="width: ${ram.percent || 0}%"></div>
                    </div>
                </div>
                
                <div class="system-stat-card">
                    <div class="system-stat-header">
                        <div class="system-stat-label">Network I/O</div>
                    </div>
                    <div class="system-stat-value">${formatBytesFromGB(network.sent_gb || 0)}</div>
                    <div class="system-stat-detail">‚Üë Sent: ${formatBytesFromGB(network.sent_mb || 0, 'MB')} | ‚Üì Recv: ${formatBytesFromGB(network.recv_mb || 0, 'MB')}</div>
                </div>
                
                <div class="system-stat-card">
                    <div class="system-stat-header">
                        <div class="system-stat-label">Output Folder</div>
                    </div>
                    <div class="system-stat-value">${formatBytes(outputFolder.size_bytes || 0)}</div>
                    <div class="system-stat-detail">${outputFolder.file_count || 0} files (all scan databases & output files)</div>
                </div>
            `;
            
            systemStatsGrid.innerHTML = statsHTML;
        }
        
        async function loadSystemStats() {
            try {
                const response = await fetch('/api/system-stats');
                if (response.ok) {
                    const systemStats = await response.json();
                    updateSystemStatsCards(systemStats);
                }
            } catch (e) {
                console.error('Error loading system stats:', e);
            }
        }
        
        window.addEventListener('load', () => {
            loadDashboard();
            loadScans();
            loadRunningScansDashboard();
            loadInitialStats(); // Load initial stats immediately
            loadSystemStats(); // Load system stats immediately
            startStatsStream(); // Start real-time updates
            
            // Consolidated polling - uses shared cache so both views share same request
            // Poll every 15 seconds (increased from 10s) - both loadScans() and loadRunningScansDashboard() use cached data
            // They'll share the same fetchScanData() call within the cache TTL
            setInterval(async () => {
                // Force refresh and update both views
                const data = await fetchScanData(true).catch(() => null);
                if (data) {
                    if (currentPage === 'scans') loadScans();
                    if (currentPage === 'dashboard') loadRunningScansDashboard();
                }
            }, 15000);
            
            // Poll dashboard and findings every 30 seconds (was 10s) to reduce server load
            setInterval(() => {
                if (currentPage === 'dashboard') loadDashboard();
                if (currentPage === 'findings') loadFindings();
            }, 30000);
        });
        
        window.addEventListener('beforeunload', () => {
            if (eventSource) eventSource.close();
            if (modalEventSource) modalEventSource.close();
            if (statsEventSource) statsEventSource.close();
            stopLogsAutoRefresh();
        });
        
        let currentConfigFile = 'api_patterns';
        let originalConfigData = null;
        let apiPatterns = [];
        let excludedExtensions = [];
        
        async function loadConfigFile() {
            const fileSelect = document.getElementById('configFileSelect');
            currentConfigFile = fileSelect.value;
            
            // Hide all editors
            document.getElementById('apiPatternsEditor').style.display = 'none';
            document.getElementById('excludedExtensionsEditor').style.display = 'none';
            
            try {
                const response = await fetch(`/api/config/${currentConfigFile}`);
                if (!response.ok) {
                    throw new Error('Failed to load config file');
                }
                
                const data = await response.json();
                const yamlContent = data.content || '';
                
                // Show appropriate editor
                if (currentConfigFile === 'api_patterns') {
                    document.getElementById('apiPatternsEditor').style.display = 'block';
                    document.getElementById('excludedExtensionsEditor').style.display = 'none';
                    document.getElementById('apiPatternsYamlEditor').value = yamlContent;
                    originalConfigData = yamlContent;
                } else if (currentConfigFile === 'excluded_extensions') {
                    document.getElementById('apiPatternsEditor').style.display = 'none';
                    document.getElementById('excludedExtensionsEditor').style.display = 'block';
                    parseExcludedExtensionsYaml(yamlContent);
                    renderExcludedExtensions();
                    originalConfigData = JSON.parse(JSON.stringify(excludedExtensions));
                }
                
                document.getElementById('configSaveStatus').textContent = 'Loaded successfully';
                document.getElementById('configSaveStatus').style.color = 'var(--success)';
                
                setTimeout(() => {
                    document.getElementById('configSaveStatus').textContent = '';
                }, 3000);
            } catch (error) {
                document.getElementById('configSaveStatus').textContent = 'Error loading config: ' + error.message;
                document.getElementById('configSaveStatus').style.color = 'var(--danger)';
            }
        }
        
        function parseApiPatternsYaml(yamlContent) {
            try {
                apiPatterns = [];
                const lines = yamlContent.split('\n');
                let currentProvider = null;
                let inNested = false;
                
                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i];
                    const trimmed = line.trim();
                    if (!trimmed || trimmed.startsWith('#')) continue;
                    
                    if (trimmed === 'api_keys:') continue;
                    
                    // Check if it's a provider name with pattern on same line: "Provider: \"pattern\""
                    const simpleMatch = trimmed.match(/^([^:]+):\s*"(.+)"$/);
                    if (simpleMatch) {
                        // If we were in nested mode, close it
                        if (inNested) {
                            inNested = false;
                            currentProvider = null;
                        }
                        apiPatterns.push({
                            provider: simpleMatch[1].trim(),
                            pattern: simpleMatch[2]
                        });
                        continue;
                    }
                    
                    // Check if it's a provider name with nested structure: "Provider:" (2 spaces indent)
                    // Match: "  Provider Name:" (exactly 2 spaces, provider name, colon, optional whitespace)
                    const providerMatch = line.match(/^  ([^:]+):\s*$/);
                    if (providerMatch) {
                        // Close previous nested if any
                        if (inNested) {
                            inNested = false;
                        }
                        currentProvider = providerMatch[1].trim();
                        inNested = true;
                        continue;
                    }
                    
                    // Check if it's a nested pattern: "      \"Sub-item\": \"pattern\"" (4 spaces indent after parent's 2 spaces = 6 total)
                    if (inNested && currentProvider) {
                        // Match lines with 4+ spaces of indentation (nested items have 4 spaces after parent's 2 spaces)
                        // Format: 4+ spaces + quoted key + colon + quoted pattern
                        // Try 6 spaces first (most common), then 4 spaces
                        let keyMatch = line.match(/^\s{6}"([^"]+)":\s*"/);
                        if (!keyMatch) {
                            keyMatch = line.match(/^\s{4}"([^"]+)":\s*"/);
                        }
                        if (keyMatch) {
                            const key = keyMatch[1];
                            // Find the pattern: everything between the opening quote after colon and the last quote
                            // Look for ": " followed by a quote, then extract until the last quote
                            const colonQuoteMatch = line.match(/":\s*"/);
                            if (colonQuoteMatch) {
                                const patternStart = colonQuoteMatch.index + colonQuoteMatch[0].length;
                                const patternEnd = line.lastIndexOf('"');
                                if (patternEnd > patternStart) {
                                    const pattern = line.substring(patternStart, patternEnd);
                                    apiPatterns.push({
                                        provider: `${currentProvider} - ${key}`,
                                        pattern: pattern
                                    });
                                    continue;
                                }
                            }
                        }
                        
                        // If we hit a line that's not nested (2 spaces or less), we're done with this nested block
                        if (line.match(/^\s{0,2}[^ ]/)) {
                            inNested = false;
                            currentProvider = null;
                        }
                    }
                }
            } catch (error) {
                console.error('Error parsing API patterns YAML:', error);
                apiPatterns = [];
            }
        }
        
        function parseExcludedExtensionsYaml(yamlContent) {
            try {
                excludedExtensions = [];
                const lines = yamlContent.split('\n');
                let inList = false;
                
                for (const line of lines) {
                    const trimmed = line.trim();
                    if (trimmed === 'excluded_extensions:') {
                        inList = true;
                        continue;
                    }
                    if (inList && trimmed.startsWith('-')) {
                        const ext = trimmed.substring(1).trim();
                        if (ext) {
                            excludedExtensions.push(ext);
                        }
                    }
                }
            } catch (error) {
                console.error('Error parsing excluded extensions YAML:', error);
                excludedExtensions = [];
            }
        }
        
        function escapeHtmlAttribute(str) {
            if (!str) return '';
            return String(str)
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#39;');
        }
        
        function renderApiPatterns() {
            const container = document.getElementById('apiPatternsList');
            if (apiPatterns.length === 0) {
                container.innerHTML = '<div class="empty-state">No patterns configured. Click "Add Pattern" to get started.</div>';
                return;
            }
            
            // Clear container
            container.innerHTML = '';
            
            apiPatterns.forEach((pattern, index) => {
                const itemDiv = document.createElement('div');
                itemDiv.className = 'config-item';
                itemDiv.style.cssText = 'display: flex; gap: 8px; margin-bottom: 12px; padding: 12px; background: var(--bg-secondary); border-radius: 6px; align-items: center;';
                
                const providerInput = document.createElement('input');
                providerInput.type = 'text';
                providerInput.className = 'form-input';
                providerInput.value = pattern.provider || '';
                providerInput.placeholder = 'Provider Name';
                providerInput.style.cssText = 'flex: 1; min-width: 200px;';
                providerInput.addEventListener('change', function() {
                    apiPatterns[index].provider = this.value;
                });
                
                const patternInput = document.createElement('input');
                patternInput.type = 'text';
                patternInput.className = 'form-input';
                patternInput.value = pattern.pattern || '';
                patternInput.placeholder = 'Regex Pattern';
                patternInput.style.cssText = 'flex: 2; min-width: 300px; font-family: monospace; font-size: 12px;';
                patternInput.addEventListener('change', function() {
                    apiPatterns[index].pattern = this.value;
                });
                
                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'btn btn-danger btn-stop';
                deleteBtn.textContent = 'üóëÔ∏è';
                deleteBtn.title = 'Delete';
                deleteBtn.addEventListener('click', function(e) {
                    e.stopPropagation();
                    removeApiPattern(index);
                });
                
                itemDiv.appendChild(providerInput);
                itemDiv.appendChild(patternInput);
                itemDiv.appendChild(deleteBtn);
                container.appendChild(itemDiv);
            });
        }
        
        function renderExcludedExtensions() {
            const container = document.getElementById('excludedExtensionsList');
            if (excludedExtensions.length === 0) {
                container.innerHTML = '<div class="empty-state">No extensions excluded. Add extensions to exclude them from scanning.</div>';
                return;
            }
            
            let html = '';
            excludedExtensions.forEach((ext, index) => {
                html += `
                    <div class="extension-tag" style="display: inline-flex; align-items: center; gap: 6px; padding: 6px 12px; background: var(--bg-secondary); border: 1px solid var(--border-color); border-radius: 4px;">
                        <span>${escapeHtml(ext)}</span>
                        <button class="btn btn-danger" style="padding: 2px 6px; font-size: 12px;" onclick="removeExcludedExtension(${index})" title="Remove">√ó</button>
                    </div>
                `;
            });
            container.innerHTML = html;
        }
        
        function addApiPattern() {
            apiPatterns.push({
                provider: '',
                pattern: ''
            });
            renderApiPatterns();
            // Scroll to the new item
            setTimeout(() => {
                const items = document.querySelectorAll('.config-item');
                if (items.length > 0) {
                    items[items.length - 1].scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                    const inputs = items[items.length - 1].querySelectorAll('input');
                    if (inputs.length > 0) inputs[0].focus();
                }
            }, 100);
        }
        
        function removeApiPattern(index) {
            if (confirm('Are you sure you want to remove this pattern?')) {
                apiPatterns.splice(index, 1);
                renderApiPatterns();
            }
        }
        
        function addExcludedExtension() {
            const input = document.getElementById('newExtensionInput');
            const ext = input.value.trim();
            if (ext) {
                // Remove dot if present
                const cleanExt = ext.startsWith('.') ? ext.substring(1) : ext;
                if (!excludedExtensions.includes(cleanExt)) {
                    excludedExtensions.push(cleanExt);
                    renderExcludedExtensions();
                    input.value = '';
                } else {
                    alert('This extension is already in the list');
                }
            }
        }
        
        function removeExcludedExtension(index) {
            excludedExtensions.splice(index, 1);
            renderExcludedExtensions();
        }
        
        function generateApiPatternsYaml() {
            let yaml = 'api_keys:\n';
            const grouped = {};
            
            // Group patterns by provider (for nested structure)
            apiPatterns.forEach(pattern => {
                if (pattern.provider && pattern.pattern) {
                    if (pattern.provider.includes(' - ')) {
                        const parts = pattern.provider.split(' - ');
                        const parent = parts[0];
                        const child = parts.slice(1).join(' - ');
                        if (!grouped[parent]) {
                            grouped[parent] = { nested: [], direct: [] };
                        }
                        grouped[parent].nested.push({ name: child, pattern: pattern.pattern });
                    } else {
                        if (!grouped[pattern.provider]) {
                            grouped[pattern.provider] = { nested: [], direct: [] };
                        }
                        grouped[pattern.provider].direct.push(pattern.pattern);
                    }
                }
            });
            
            // Generate YAML - preserve order by processing all patterns in order
            const processedProviders = new Set();
            
            // First pass: output nested providers (in order they appear)
            apiPatterns.forEach(pattern => {
                if (pattern.provider && pattern.pattern && pattern.provider.includes(' - ')) {
                    const parts = pattern.provider.split(' - ');
                    const parent = parts[0];
                    if (!processedProviders.has(parent)) {
                        processedProviders.add(parent);
                        const group = grouped[parent];
                        if (group && group.nested.length > 0) {
                            yaml += `  ${parent}:\n`;
                            // Output nested items in order they appear in apiPatterns (6 spaces for nested items)
                            apiPatterns.forEach(p => {
                                if (p.provider && p.provider.startsWith(parent + ' - ')) {
                                    const childName = p.provider.substring(parent.length + 3);
                                    yaml += `      "${childName}": "${p.pattern.replace(/"/g, '\\"')}"\n`;
                                }
                            });
                        }
                    }
                }
            });
            
            // Second pass: output direct (non-nested) providers
            apiPatterns.forEach(pattern => {
                if (pattern.provider && pattern.pattern && !pattern.provider.includes(' - ')) {
                    const provider = pattern.provider;
                    if (!processedProviders.has(provider)) {
                        processedProviders.add(provider);
                        yaml += `  ${provider}: "${pattern.pattern.replace(/"/g, '\\"')}"\n`;
                    }
                }
            });
            
            return yaml;
        }
        
        function generateExcludedExtensionsYaml() {
            let yaml = 'excluded_extensions:\n';
            excludedExtensions.forEach(ext => {
                if (ext.trim()) {
                    yaml += `  - ${ext.trim()}\n`;
                }
            });
            return yaml;
        }
        
        async function saveConfigFile() {
            let yamlContent = '';
            
            if (currentConfigFile === 'api_patterns') {
                yamlContent = document.getElementById('apiPatternsYamlEditor').value;
            } else if (currentConfigFile === 'excluded_extensions') {
                yamlContent = generateExcludedExtensionsYaml();
            }
            
            try {
                const response = await fetch(`/api/config/${currentConfigFile}`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({ content: yamlContent })
                });
                
                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error || 'Failed to save config file');
                }
                
                // Update original data
                if (currentConfigFile === 'api_patterns') {
                    originalConfigData = yamlContent;
                } else {
                    originalConfigData = JSON.parse(JSON.stringify(excludedExtensions));
                }
                
                document.getElementById('configSaveStatus').textContent = 'Saved successfully';
                document.getElementById('configSaveStatus').style.color = 'var(--success)';
                
                setTimeout(() => {
                    document.getElementById('configSaveStatus').textContent = '';
                }, 3000);
            } catch (error) {
                document.getElementById('configSaveStatus').textContent = 'Error saving config: ' + error.message;
                document.getElementById('configSaveStatus').style.color = 'var(--danger)';
            }
        }
        
        function resetConfigFile() {
            if (confirm('Are you sure you want to reset to the last saved version? All unsaved changes will be lost.')) {
                if (currentConfigFile === 'api_patterns' && originalConfigData) {
                    document.getElementById('apiPatternsYamlEditor').value = originalConfigData;
                } else if (currentConfigFile === 'excluded_extensions' && originalConfigData) {
                    excludedExtensions = JSON.parse(JSON.stringify(originalConfigData));
                    renderExcludedExtensions();
                }
                document.getElementById('configSaveStatus').textContent = 'Reset to last saved version';
                document.getElementById('configSaveStatus').style.color = 'var(--text-secondary)';
                
                setTimeout(() => {
                    document.getElementById('configSaveStatus').textContent = '';
                }, 3000);
            }
        }
        
        // New Config Management Functions (Database-based)
        let currentConfigTab = 'api_patterns';
        
        function switchConfigTab(tab) {
            currentConfigTab = tab;
            document.querySelectorAll('.config-tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.config-tab-content').forEach(c => c.classList.remove('active'));
            
            const tabBtn = document.querySelector(`.config-tab[onclick="switchConfigTab('${tab}')"]`);
            if (tabBtn) tabBtn.classList.add('active');
            const tabContent = document.getElementById(`config-tab-${tab}`);
            if (tabContent) tabContent.classList.add('active');
            
            loadConfigTab(tab);
        }
        
        async function loadSettingsPage() {
            loadConfigTab(currentConfigTab);
        }
        
        async function loadConfigTab(tab) {
            if (tab === 'api_patterns') {
                await loadApiPatterns();
            } else if (tab === 'excluded_extensions') {
                await loadExcludedExtensions();
            } else if (tab === 'xss_payloads') {
                await loadXssPayloads();
            }
        }
        
        async function loadApiPatterns() {
            try {
                const response = await fetch('/api/config/api_patterns');
                if (!response.ok) throw new Error('Failed to load API patterns');
                
                const data = await response.json();
                renderApiPatternsTable(data.patterns || []);
            } catch (error) {
                showConfigStatus('Error loading API patterns: ' + error.message, 'error');
            }
        }
        
        function renderApiPatternsTable(patterns) {
            const container = document.getElementById('apiPatternsTableContainer');
            if (!container) return;
            
            if (patterns.length === 0) {
                container.innerHTML = '<div class="empty-state">No API patterns found. Click "Add Pattern" to get started.</div>';
                return;
            }
            
            let html = '<table class="config-table"><thead><tr><th>Provider</th><th>Pattern</th><th>Type</th><th>Status</th><th>Actions</th></tr></thead><tbody>';
            
            patterns.forEach(pattern => {
                const isDeleted = pattern.deleted_at !== null;
                const isUserAdded = pattern.is_user_added;
                const providerEscaped = escapeHtml(pattern.provider);
                const patternEscaped = escapeHtml(pattern.pattern);
                
                html += `<tr class="${isDeleted ? 'deleted' : ''}">`;
                html += `<td>${providerEscaped}</td>`;
                html += `<td><span class="monospace">${patternEscaped}</span></td>`;
                html += `<td><span class="badge ${isUserAdded ? 'badge-user' : 'badge-system'}">${isUserAdded ? 'User' : 'System'}</span></td>`;
                html += `<td><span class="badge ${isDeleted ? 'badge-deleted' : ''}">${isDeleted ? 'Deleted' : 'Active'}</span></td>`;
                html += `<td class="config-actions">`;
                if (isDeleted) {
                    html += `<button class="btn" onclick="restoreApiPattern(${pattern.id})" title="Restore">‚Ü∫ Restore</button>`;
                } else {
                    html += `<button class="btn" onclick="editApiPattern(${pattern.id}, '${escapeHtmlAttribute(pattern.provider)}', '${escapeHtmlAttribute(pattern.pattern)}')" title="Edit">‚úèÔ∏è Edit</button>`;
                    html += `<button class="btn btn-danger" onclick="deleteApiPattern(${pattern.id})" title="Delete">üóëÔ∏è Delete</button>`;
                }
                html += `</td></tr>`;
            });
            
            html += '</tbody></table>';
            container.innerHTML = html;
        }
        
        async function loadExcludedExtensions() {
            try {
                const response = await fetch('/api/config/excluded_extensions');
                if (!response.ok) throw new Error('Failed to load excluded extensions');
                
                const data = await response.json();
                renderExcludedExtensionsTable(data.extensions || []);
            } catch (error) {
                showConfigStatus('Error loading excluded extensions: ' + error.message, 'error');
            }
        }
        
        function renderExcludedExtensionsTable(extensions) {
            const container = document.getElementById('excludedExtensionsTableContainer');
            if (!container) return;
            
            if (extensions.length === 0) {
                container.innerHTML = '<div class="empty-state">No excluded extensions found. Click "Add Extension" to get started.</div>';
                return;
            }
            
            let html = '<table class="config-table"><thead><tr><th>Extension</th><th>Type</th><th>Status</th><th>Actions</th></tr></thead><tbody>';
            
            extensions.forEach(ext => {
                const isDeleted = ext.deleted_at !== null;
                const isUserAdded = ext.is_user_added;
                const extEscaped = escapeHtml(ext.extension);
                
                html += `<tr class="${isDeleted ? 'deleted' : ''}">`;
                html += `<td>${extEscaped}</td>`;
                html += `<td><span class="badge ${isUserAdded ? 'badge-user' : 'badge-system'}">${isUserAdded ? 'User' : 'System'}</span></td>`;
                html += `<td><span class="badge ${isDeleted ? 'badge-deleted' : ''}">${isDeleted ? 'Deleted' : 'Active'}</span></td>`;
                html += `<td class="config-actions">`;
                if (isDeleted) {
                    html += `<button class="btn" onclick="restoreExcludedExtension(${ext.id})" title="Restore">‚Ü∫ Restore</button>`;
                } else {
                    html += `<button class="btn btn-danger" onclick="deleteExcludedExtension(${ext.id})" title="Delete">üóëÔ∏è Delete</button>`;
                }
                html += `</td></tr>`;
            });
            
            html += '</tbody></table>';
            container.innerHTML = html;
        }
        
        async function loadXssPayloads() {
            try {
                const response = await fetch('/api/config/xss_payloads');
                if (!response.ok) throw new Error('Failed to load XSS payloads');
                
                const data = await response.json();
                renderXssPayloadsTable(data.payloads || []);
            } catch (error) {
                showConfigStatus('Error loading XSS payloads: ' + error.message, 'error');
            }
        }
        
        function renderXssPayloadsTable(payloads) {
            const container = document.getElementById('xssPayloadsTableContainer');
            if (!container) return;
            
            if (payloads.length === 0) {
                container.innerHTML = '<div class="empty-state">No XSS payloads found. Click "Add Payload" to get started.</div>';
                return;
            }
            
            let html = '<table class="config-table"><thead><tr><th>Payload</th><th>Default</th><th>Type</th><th>Status</th><th>Actions</th></tr></thead><tbody>';
            
            payloads.forEach(payload => {
                const isDeleted = payload.deleted_at !== null;
                const isUserAdded = payload.is_user_added;
                const isDefault = payload.is_default;
                const payloadEscaped = escapeHtml(payload.payload);
                
                html += `<tr class="${isDeleted ? 'deleted' : ''}">`;
                html += `<td><span class="monospace" style="max-width: 500px; display: inline-block; word-break: break-all;">${payloadEscaped}</span></td>`;
                html += `<td>${isDefault ? '<span class="badge badge-default">Default</span>' : '-'}</td>`;
                html += `<td><span class="badge ${isUserAdded ? 'badge-user' : 'badge-system'}">${isUserAdded ? 'User' : 'System'}</span></td>`;
                html += `<td><span class="badge ${isDeleted ? 'badge-deleted' : ''}">${isDeleted ? 'Deleted' : 'Active'}</span></td>`;
                html += `<td class="config-actions">`;
                if (isDeleted) {
                    html += `<button class="btn" onclick="restoreXssPayload(${payload.id})" title="Restore">‚Ü∫ Restore</button>`;
                } else {
                    html += `<button class="btn" onclick="editXssPayload(${payload.id}, '${escapeHtmlAttribute(payload.payload)}', ${isDefault})" title="Edit">‚úèÔ∏è Edit</button>`;
                    if (!isDefault) {
                        html += `<button class="btn" onclick="setDefaultXssPayload(${payload.id})" title="Set as Default">‚≠ê Set Default</button>`;
                    }
                    html += `<button class="btn btn-danger" onclick="deleteXssPayload(${payload.id})" title="Delete">üóëÔ∏è Delete</button>`;
                }
                html += `</td></tr>`;
            });
            
            html += '</tbody></table>';
            container.innerHTML = html;
        }
        
        function showConfigStatus(message, type = 'success') {
            const statusEl = document.getElementById('configStatusMessage');
            if (!statusEl) return;
            statusEl.textContent = message;
            statusEl.style.display = 'block';
            statusEl.style.background = type === 'error' ? 'rgba(255, 68, 68, 0.1)' : 'rgba(0, 255, 136, 0.1)';
            statusEl.style.border = `1px solid ${type === 'error' ? 'var(--danger)' : 'var(--success)'}`;
            statusEl.style.color = type === 'error' ? 'var(--danger)' : 'var(--success)';
            
            setTimeout(() => {
                statusEl.style.display = 'none';
            }, 5000);
        }
        
        function showAddApiPatternModal() {
            const provider = prompt('Enter provider name:');
            if (!provider) return;
            const pattern = prompt('Enter regex pattern:');
            if (!pattern) return;
            
            addApiPattern(provider.trim(), pattern.trim());
        }
        
        async function addApiPattern(provider, pattern) {
            try {
                const response = await fetch('/api/config/api_patterns', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({provider, pattern})
                });
                
                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error || 'Failed to add pattern');
                }
                
                showConfigStatus('API pattern added successfully');
                await loadApiPatterns();
            } catch (error) {
                showConfigStatus('Error: ' + error.message, 'error');
            }
        }
        
        function editApiPattern(id, provider, pattern) {
            const newProvider = prompt('Enter provider name:', provider);
            if (newProvider === null) return;
            const newPattern = prompt('Enter regex pattern:', pattern);
            if (newPattern === null) return;
            
            updateApiPattern(id, newProvider.trim(), newPattern.trim());
        }
        
        async function updateApiPattern(id, provider, pattern) {
            try {
                const response = await fetch(`/api/config/api_patterns/${id}`, {
                    method: 'PUT',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({provider, pattern})
                });
                
                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error || 'Failed to update pattern');
                }
                
                showConfigStatus('API pattern updated successfully');
                await loadApiPatterns();
            } catch (error) {
                showConfigStatus('Error: ' + error.message, 'error');
            }
        }
        
        async function deleteApiPattern(id) {
            if (!confirm('Are you sure you want to delete this pattern? It will be soft-deleted and can be restored later.')) return;
            
            try {
                const response = await fetch(`/api/config/api_patterns/${id}`, {method: 'DELETE'});
                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error || 'Failed to delete pattern');
                }
                
                showConfigStatus('API pattern deleted successfully');
                await loadApiPatterns();
            } catch (error) {
                showConfigStatus('Error: ' + error.message, 'error');
            }
        }
        
        async function restoreApiPattern(id) {
            try {
                const response = await fetch(`/api/config/api_patterns/${id}/restore`, {method: 'POST'});
                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error || 'Failed to restore pattern');
                }
                
                showConfigStatus('API pattern restored successfully');
                await loadApiPatterns();
            } catch (error) {
                showConfigStatus('Error: ' + error.message, 'error');
            }
        }
        
        function showAddExtensionModal() {
            const extension = prompt('Enter extension (without dot, e.g., "css"):');
            if (!extension) return;
            
            let cleanExt = extension.trim();
            if (cleanExt.startsWith('.')) {
                cleanExt = cleanExt.substring(1);
            }
            addExcludedExtension(cleanExt);
        }
        
        async function addExcludedExtension(extension) {
            try {
                const response = await fetch('/api/config/excluded_extensions', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({extension})
                });
                
                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error || 'Failed to add extension');
                }
                
                showConfigStatus('Extension added successfully');
                await loadExcludedExtensions();
            } catch (error) {
                showConfigStatus('Error: ' + error.message, 'error');
            }
        }
        
        async function deleteExcludedExtension(id) {
            if (!confirm('Are you sure you want to delete this extension? It will be soft-deleted and can be restored later.')) return;
            
            try {
                const response = await fetch(`/api/config/excluded_extensions/${id}`, {method: 'DELETE'});
                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error || 'Failed to delete extension');
                }
                
                showConfigStatus('Extension deleted successfully');
                await loadExcludedExtensions();
            } catch (error) {
                showConfigStatus('Error: ' + error.message, 'error');
            }
        }
        
        async function restoreExcludedExtension(id) {
            try {
                const response = await fetch(`/api/config/excluded_extensions/${id}/restore`, {method: 'POST'});
                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error || 'Failed to restore extension');
                }
                
                showConfigStatus('Extension restored successfully');
                await loadExcludedExtensions();
            } catch (error) {
                showConfigStatus('Error: ' + error.message, 'error');
            }
        }
        
        function showAddXssPayloadModal() {
            const payload = prompt('Enter XSS payload:');
            if (!payload) return;
            const isDefault = confirm('Set as default payload?');
            
            addXssPayload(payload.trim(), isDefault);
        }
        
        async function addXssPayload(payload, isDefault) {
            try {
                const response = await fetch('/api/config/xss_payloads', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({payload, is_default: isDefault})
                });
                
                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error || 'Failed to add payload');
                }
                
                showConfigStatus('XSS payload added successfully');
                await loadXssPayloads();
            } catch (error) {
                showConfigStatus('Error: ' + error.message, 'error');
            }
        }
        
        function editXssPayload(id, payload, isDefault) {
            const newPayload = prompt('Enter XSS payload:', payload);
            if (newPayload === null) return;
            const newIsDefault = confirm('Set as default payload?', isDefault);
            
            updateXssPayload(id, newPayload.trim(), newIsDefault);
        }
        
        async function updateXssPayload(id, payload, isDefault) {
            try {
                const response = await fetch(`/api/config/xss_payloads/${id}`, {
                    method: 'PUT',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({payload, is_default: isDefault})
                });
                
                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error || 'Failed to update payload');
                }
                
                showConfigStatus('XSS payload updated successfully');
                await loadXssPayloads();
            } catch (error) {
                showConfigStatus('Error: ' + error.message, 'error');
            }
        }
        
        async function setDefaultXssPayload(id) {
            if (!confirm('Set this payload as the default? This will unset the current default.')) return;
            
            try {
                const response = await fetch('/api/config/xss_payloads');
                const data = await response.json();
                const payload = data.payloads.find(p => p.id === id);
                if (!payload) throw new Error('Payload not found');
                
                await updateXssPayload(id, payload.payload, true);
            } catch (error) {
                showConfigStatus('Error: ' + error.message, 'error');
            }
        }
        
        async function deleteXssPayload(id) {
            if (!confirm('Are you sure you want to delete this payload? It will be soft-deleted and can be restored later.')) return;
            
            try {
                const response = await fetch(`/api/config/xss_payloads/${id}`, {method: 'DELETE'});
                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error || 'Failed to delete payload');
                }
                
                showConfigStatus('XSS payload deleted successfully');
                await loadXssPayloads();
            } catch (error) {
                showConfigStatus('Error: ' + error.message, 'error');
            }
        }
        
        async function restoreXssPayload(id) {
            try {
                const response = await fetch(`/api/config/xss_payloads/${id}/restore`, {method: 'POST'});
                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error || 'Failed to restore payload');
                }
                
                showConfigStatus('XSS payload restored successfully');
                await loadXssPayloads();
            } catch (error) {
                showConfigStatus('Error: ' + error.message, 'error');
            }
        }
        
        async function syncConfigsFromYaml() {
            if (!confirm('Sync all configs from YAML files? This will add new items and soft-delete removed items.')) return;
            
            try {
                const response = await fetch('/api/config/sync', {method: 'POST'});
                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error || 'Failed to sync configs');
                }
                
                showConfigStatus('Configs synced successfully from YAML files');
                await loadConfigTab(currentConfigTab);
            } catch (error) {
                showConfigStatus('Error: ' + error.message, 'error');
            }
        }
        
        // Load version on page load
        async function loadVersion() {
            try {
                const response = await fetch('/api/version');
                if (response.ok) {
                    const data = await response.json();
                    const versionElement = document.getElementById('appVersion');
                    if (versionElement) {
                        versionElement.textContent = data.version;
                    }
                }
            } catch (error) {
                console.error('Error loading version:', error);
            }
        }

        // Allow Enter key to add extension
        document.addEventListener('DOMContentLoaded', () => {
            loadVersion();
            const extensionInput = document.getElementById('newExtensionInput');
            if (extensionInput) {
                extensionInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        addExcludedExtension();
                    }
                });
            }
        });
    </script>
</body>
</html>
